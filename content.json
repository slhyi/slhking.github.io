[{"title":"【嵌入式Linux应用】温湿度监控系统——学习paho mqtt的基本操作","date":"2022-07-04T07:51:53.526Z","path":"2022/07/04/LinuxApp-5-MultiThreadAndShowTemp/","text":"1. 概述​ 本篇的重点是解析paho mqtt官方例程，学习它的一些结构体、API和回调的处理，然后再学习下Linux中的线程和线程间数据通信，掌握相关API的使用，最后综合起来，使用多线程publish或处理subscribe的主题的消息，将订阅的温湿度消息解析出来在LVGL的表格中用折线图的方式显示出来。 2. paho mqtt基本操作​ 我们使用mqtt有如下几个操作： 创建&#x2F;销毁客户端 连接&#x2F;断开连接服务器 订阅&#x2F;取消订阅主题 处理订阅消息 发布主题消息 这些操作在paho mqtt的源码中，基于同步处理方式和异步处理方式又有不同的API，所以我们在使用paho mqtt的时候要在一开始就要定位好要选择哪种方式。 2.1 创建客户端2.1.1 创建同步客户端 客户端句柄：MQTTClient 12345// MQTTClient.htypedef void* MQTTClient;// .c文件中定义客户端句柄MQTTClient client; 创建客户端 12345678910111213int MQTTClient_create(MQTTClient* handle, const char* serverURI, const char* clientId, int persistence_type, void* persistence_context)&#123; return MQTTClient_createWithOptions(handle, serverURI, clientId, persistence_type, persistence_context, NULL);&#125; 可以看到这个函数调用了另一个函数MQTTClient_createWithOptions，它的原型定义： 123456int MQTTClient_createWithOptions(MQTTClient* handle, const char* serverURI, const char* clientId, int persistence_type, void* persistence_context, MQTTClient_createOptions* options) 关于这个函数参数的释义： 参数名称 作用描述 handle MQTT客户端句柄 serverURI MQTT服务器地址 clientId 登录MQTT服务器时使用的客户端ID persistence_type 客户端的持续类型：MQTTCLIENT_PERSISTENCE_NONE: 当客户端运行失败或者下线了，正在发布的消息会立刻丢失，即便是QOS1或QOS2类型的消息质量；MQTTCLIENT_PERSISTENCE_DEFAULT:客户端下线后正在发布的消息会被保存到指定的目录persistence_context中，此时persistence_context可以被指定为NULL；MQTTCLIENT_PERSISTENCE_USER:客户端下线后正在发布的消息会被保存到指定的目录persistence_context中，此时persistence_context必须被指定不能为NULL persistence_context 保存消息的目录 options 创建客户端的额外操作 返回值 如果成功返回MQTTCLIENT_SUCCESS否则返回错误码 123456789101112131415161718#include &lt;stdio.h&gt;#include &quot;MQTTClient.h&quot;#define ADDRESS &quot;tcp://mqtt.eclipse.org:1883&quot;#define CLIENTID &quot;ExampleClientPub&quot;MQTTClient client;int rc;if ((rc = MQTTClient_create(&amp;client, ADDRESS, CLIENTID, MQTTCLIENT_PERSISTENCE_NONE, NULL)) != MQTTCLIENT_SUCCESS)&#123; printf(&quot;Failed to create client, return code %d\\n&quot;, rc); exit(EXIT_FAILURE);&#125; 2.1.2 创建异步客户端 客户端句柄：MQTTAsync 12345// MQTTAsync.htypedef void* MQTTAsync;// .CMQTTAsync client; 创建客户端 123456789101112131415int MQTTAsync_create(MQTTAsync* handle, const char* serverURI, const char* clientId, int persistence_type, void* persistence_context)&#123; MQTTAsync_init_rand(); return MQTTAsync_createWithOptions(handle, serverURI, clientId, persistence_type, persistence_context, NULL);&#125; 123456int MQTTAsync_createWithOptions(MQTTAsync* handle, const char* serverURI, const char* clientId, int persistence_type, void* persistence_context, MQTTAsync_createOptions* options) 其实和同步的创建是差不多的，参数意义也几乎是一样的，就不在重复解释了，下面是应用： 123456789101112131415161718#include &lt;stdio.h&gt;#include &quot;MQTTAsync.h&quot;#define ADDRESS &quot;tcp://mqtt.eclipse.org:1883&quot;#define CLIENTID &quot;ExampleClientPub&quot;MQTTAsync client;int rc;if ((rc = MQTTAsync_create(&amp;client, ADDRESS, CLIENTID, MQTTCLIENT_PERSISTENCE_NONE, NULL)) != MQTTASYNC_SUCCESS)&#123; printf(&quot;Failed to create client object, return code %d\\n&quot;, rc); exit(EXIT_FAILURE);&#125; 2.2 销毁客户端 销毁同步客户端 1void MQTTClient_destroy(MQTTClient* handle) ​ 传入的参数就是同步客户端的句柄： 12MQTTClient client;MQTTClient_destroy(&amp;client); 销毁异步客户端 1void MQTTAsync_destroy(MQTTAsync* handle) ​ 传入的参数就是异步客户端的句柄： 12MQTTAsync client;MQTTAsync_destroy(&amp;client); 2.3 回调函数设置​ 我们可以使用这个设置回调函数的API将MQTT的一些消息处理放到多线程里面，在paho mqtt中有个设置回调函数的API，在这个API中指定下面几个操作的处理回调函数： 和服务器的连接异常丢失了：这种情况通常会在发布过程、发送心跳包没有得到响应的情况下被发现和服务器的连接断开了； 处理订阅的消息； 成功发布消息后的处理； 函数原型： 同步客户端 12345int MQTTClient_setCallbacks(MQTTClient handle, void* context, MQTTClient_connectionLost* cl, MQTTClient_messageArrived* ma, MQTTClient_deliveryComplete* dc) 参数名称 描述 handle mqtt客户端 context 用户自定义的背景信息处理回调函数：客户端ID、用户名和密码这些信息 cl 连接丢失处理回调函数 ma 处理订阅消息的回调函数 dc 成功发布消息后的回到函数 返回值 MQTTCLIENT_SUCCESS或者错误码 异步客户端 1234int MQTTAsync_setCallbacks(MQTTAsync handle, void* context, MQTTAsync_connectionLost* cl, MQTTAsync_messageArrived* ma, MQTTAsync_deliveryComplete* dc) 参数作用和同步客户端的是一样的。 2.4 和服务器建立连接2.4.1 同步客户端建立连接​ 和服务器建立连接需要定义一个连接控制包，其结构体的定义如下(删掉了注释)： 123456789101112131415161718192021222324252627282930313233343536typedef struct&#123; char struct_id[4]; int struct_version; int keepAliveInterval; int cleansession; int reliable; MQTTClient_willOptions* will; const char* username; const char* password; int connectTimeout; int retryInterval; MQTTClient_SSLOptions* ssl; int serverURIcount; char* const* serverURIs; int MQTTVersion; struct &#123; const char* serverURI; /**&lt; the serverURI connected to */ int MQTTVersion; /**&lt; the MQTT version used to connect with */ /**&lt; if the MQTT version is 3.1.1, the value of sessionPresent returned in the connack */ int sessionPresent; &#125; returned; struct &#123; int len; /**&lt; binary password length */ const void* data; /**&lt; binary password data */ &#125; binarypwd; int maxInflightMessages; int cleanstart; const MQTTClient_nameValue* httpHeaders; const char* httpProxy; const char* httpsProxy;&#125; MQTTClient_connectOptions; 下表是对参数的解释： 参数名称 解释 struct_id 必须是’M’’Q’’T’’C’ struct_version 0-没有SSL和多服务器；1-没有多服务器；2-没有MQTT版本；3-建立连接后没有返回值；4-不支持二进制密码操作;5-不支持maxInflightMessages和清除开始标志;6-不支持HTTP headers;7-不支持HTTP代理 keepAliveInterval 保活周期，客户端向服务器发送心跳包的周期，单位秒 cleansession 会话清楚标志，用来告诉服务器是否清除当前客户端上一次建立连接后产生的会话消息，1清除，0保持 reliable 是否支持发布多重消息；0支持同时最多10消息处于发布状态；1不支持多消息发布，必须等待上一次发布完成后才能发布下一条消息 will 遗嘱操作，设置遗嘱topic和消息 username 登录服务器用的用户名 password 登录服务器用的密码 connectTimeout 连接超时时间 retryInterval 发布消息但没有收到服务器响应的话，重发retryInterval这么多秒；0关闭重发； ssl ssl操作，设置SSL属性 serverURIcount 服务器数量，默认是0 serverURIs 服务器地址 MQTTVersion MQTT版本：0-默认版本3.1.1，连接失败的话回退使用3.1版本；3-只会尝试用3.1版本和服务器建立连接；4-只会尝试用3.1.1版本和服务器建立连接；5-5.0版本 returned 建立连接成功后服务器的响应信息 binarypwd 登录服务器用的二进制密码，里面设置密码长度和密码内容 maxInflightMessages 如果支持多消息一起发布的话，这个值设置多消息的最大数量 cleanstart 5.0版本下的MQTT支持清除开始标志 httpHeaders http头部信息 httpProxy http代理 httpsProxy https的代理 paho mqtt使用宏定义了几个初始化的连接控制包： 123456781. 通用3.x版本的无遗嘱无SSL的连接控制包#define MQTTClient_connectOptions_initializer &#123; &#123;&#x27;M&#x27;, &#x27;Q&#x27;, &#x27;T&#x27;, &#x27;C&#x27;&#125;, 8, 60, 1, 1, NULL, NULL, NULL, 30, 0, NULL,0, NULL, MQTTVERSION_DEFAULT, &#123;NULL, 0, 0&#125;, &#123;0, NULL&#125;, -1, 0, NULL, NULL, NULL&#125;2. 通用5.0版本的无遗嘱无SSL的连接控制包#define MQTTClient_connectOptions_initializer5 &#123; &#123;&#x27;M&#x27;, &#x27;Q&#x27;, &#x27;T&#x27;, &#x27;C&#x27;&#125;, 8, 60, 0, 1, NULL, NULL, NULL, 30, 0, NULL,0, NULL, MQTTVERSION_5, &#123;NULL, 0, 0&#125;, &#123;0, NULL&#125;, -1, 1, NULL, NULL, NULL&#125;3. 3.x版本有遗嘱和SSL#define MQTTClient_connectOptions_initializer_ws &#123; &#123;&#x27;M&#x27;, &#x27;Q&#x27;, &#x27;T&#x27;, &#x27;C&#x27;&#125;, 8, 45, 1, 1, NULL, NULL, NULL, 30, 0, NULL,0, NULL, MQTTVERSION_DEFAULT, &#123;NULL, 0, 0&#125;, &#123;0, NULL&#125;, -1, 0, NULL, NULL, NULL&#125;4. 5.0版本有遗嘱和SSL#define MQTTClient_connectOptions_initializer5_ws &#123; &#123;&#x27;M&#x27;, &#x27;Q&#x27;, &#x27;T&#x27;, &#x27;C&#x27;&#125;, 8, 45, 0, 1, NULL, NULL, NULL, 30, 0, NULL,0, NULL, MQTTVERSION_5, &#123;NULL, 0, 0&#125;, &#123;0, NULL&#125;, -1, 1, NULL, NULL, NULL&#125; 我们在初始化连接的时候，需要先定义连接控制包结构体变量，然后将例如用户名、密码等信息复制后在调用连接API登录服务器。和服务器建立连接的API原型： 1LIBMQTT_API int MQTTClient_connect(MQTTClient handle, MQTTClient_connectOptions* options); 第一个参数就是客户端句柄，第二个参数是连接控制包的结构体变量指针，所以我们的用法是： 12345678910MQTTClient_connectOptions conn_opts = MQTTClient_connectOptions_initializer;int rc;conn_opts.keepAliveInterval = 20;conn_opts.cleansession = 1;if ((rc = MQTTClient_connect(client, &amp;conn_opts)) != MQTTCLIENT_SUCCESS)&#123; printf(&quot;Failed to connect, return code %d\\n&quot;, rc); rc = EXIT_FAILURE; goto destroy_exit;&#125; 2.4.2 异步客户端建立连接​ 异步客户端的连接方法和同步客户端几乎是一样的，只是连接控制包结构体的名称和连接函数名不一样，并且异步客户端可以将连接成功&#x2F;失败的处理放入回调函数中，用异步的方式处理： 1234567891011typedef struct&#123;...&#125;MQTTAsync_connectOptions;#define MQTTAsync_connectOptions_initializer &#123; &#123;&#x27;M&#x27;, &#x27;Q&#x27;, &#x27;T&#x27;, &#x27;C&#x27;&#125;, 8, 60, 1, 65535, NULL, NULL, NULL, 30, 0,NULL, NULL, NULL, NULL, 0, NULL, MQTTVERSION_DEFAULT, 0, 1, 60, &#123;0, NULL&#125;, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL&#125;#define MQTTAsync_connectOptions_initializer5 &#123; &#123;&#x27;M&#x27;, &#x27;Q&#x27;, &#x27;T&#x27;, &#x27;C&#x27;&#125;, 8, 60, 0, 65535, NULL, NULL, NULL, 30, 0,NULL, NULL, NULL, NULL, 0, NULL, MQTTVERSION_5, 0, 1, 60, &#123;0, NULL&#125;, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL&#125;#define MQTTAsync_connectOptions_initializer_ws &#123; &#123;&#x27;M&#x27;, &#x27;Q&#x27;, &#x27;T&#x27;, &#x27;C&#x27;&#125;, 8, 45, 1, 65535, NULL, NULL, NULL, 30, 0,NULL, NULL, NULL, NULL, 0, NULL, MQTTVERSION_DEFAULT, 0, 1, 60, &#123;0, NULL&#125;, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL&#125;#define MQTTAsync_connectOptions_initializer5_ws &#123; &#123;&#x27;M&#x27;, &#x27;Q&#x27;, &#x27;T&#x27;, &#x27;C&#x27;&#125;, 8, 45, 0, 65535, NULL, NULL, NULL, 30, 0,NULL, NULL, NULL, NULL, 0, NULL, MQTTVERSION_5, 0, 1, 60, &#123;0, NULL&#125;, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL&#125;LIBMQTT_API int MQTTAsync_connect(MQTTAsync handle, const MQTTAsync_connectOptions* options); 用法也类似： 123456789101112131415161718192021222324252627MQTTAsync_connectOptions conn_opts = MQTTAsync_connectOptions_initializer;int rc;conn_opts.keepAliveInterval = 20;conn_opts.cleansession = 1;conn_opts.onSuccess = onConnect;conn_opts.onFailure = onConnectFailure;conn_opts.context = client;if ((rc = MQTTAsync_connect(client, &amp;conn_opts)) != MQTTASYNC_SUCCESS)&#123; printf(&quot;Failed to start connect, return code %d\\n&quot;, rc); exit(EXIT_FAILURE);&#125;void onConnectFailure(void* context, MQTTAsync_failureData* response)&#123; printf(&quot;Connect failed, rc %d\\n&quot;, response-&gt;code); finished = 1;&#125;void onConnect(void* context, MQTTAsync_successData* response)&#123; MQTTAsync client = (MQTTAsync)context; MQTTAsync_responseOptions opts = MQTTAsync_responseOptions_initializer; int rc; printf(&quot;Successful connection\\n&quot;);&#125; 2.5 和服务器断开连接​ 在断开连接上，同步客户端和异步客户端区别有点大，传入的参数有差异。 2.5.1 同步客户端断开连接​ 同步客户端断开服务器连接的API原型： 1LIBMQTT_API int MQTTClient_disconnect(MQTTClient handle, int timeout); 只需要两个参数:MQTT客户端和断开连接超时时间： 12345678MQTTClient client;int rc;if ((rc = MQTTClient_disconnect(client, 10000)) != MQTTCLIENT_SUCCESS)&#123; printf(&quot;Failed to disconnect, return code %d\\n&quot;, rc); rc = EXIT_FAILURE;&#125; 2.5.2 异步客户端断开连接​ 异步客户端断开和服务器的连接需要操作一个控制结构体： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556typedef struct&#123; /** The eyecatcher for this structure. Must be MQTD. */ char struct_id[4]; /** The version number of this structure. Must be 0 or 1. 0 signifies no V5 properties */ int struct_version; /** * The client delays disconnection for up to this time (in * milliseconds) in order to allow in-flight message transfers to complete. */ int timeout; /** * A pointer to a callback function to be called if the disconnect successfully * completes. Can be set to NULL, in which case no indication of successful * completion will be received. */ MQTTAsync_onSuccess* onSuccess; /** * A pointer to a callback function to be called if the disconnect fails. * Can be set to NULL, in which case no indication of unsuccessful * completion will be received. */ MQTTAsync_onFailure* onFailure; /** * A pointer to any application-specific context. The * the &lt;i&gt;context&lt;/i&gt; pointer is passed to success or failure callback functions to * provide access to the context information in the callback. */ void* context; /** * MQTT V5 input properties */ MQTTProperties properties; /** * Reason code for MQTTV5 disconnect */ enum MQTTReasonCodes reasonCode; /** * A pointer to a callback function to be called if the disconnect successfully * completes. Can be set to NULL, in which case no indication of successful * completion will be received. */ MQTTAsync_onSuccess5* onSuccess5; /** * A pointer to a callback function to be called if the disconnect fails. * Can be set to NULL, in which case no indication of unsuccessful * completion will be received. */ MQTTAsync_onFailure5* onFailure5;&#125; MQTTAsync_disconnectOptions;#define MQTTAsync_disconnectOptions_initializer &#123; &#123;&#x27;M&#x27;, &#x27;Q&#x27;, &#x27;T&#x27;, &#x27;D&#x27;&#125;, 0, 0, NULL, NULL, NULL,\\ MQTTProperties_initializer, MQTTREASONCODE_SUCCESS, NULL, NULL &#125;#define MQTTAsync_disconnectOptions_initializer5 &#123; &#123;&#x27;M&#x27;, &#x27;Q&#x27;, &#x27;T&#x27;, &#x27;D&#x27;&#125;, 1, 0, NULL, NULL, NULL,\\ MQTTProperties_initializer, MQTTREASONCODE_SUCCESS, NULL, NULL &#125; 结构体成员较少且英文也不难看懂，就不做翻译工作了，异步客户端断开服务器连接的API原型： 12LIBMQTT_API int MQTTAsync_disconnect(MQTTAsync handle, const MQTTAsync_disconnectOptions* options);LIBMQTT_API int MQTTClient_disconnect5(MQTTClient handle, int timeout, enum MQTTReasonCodes reason, MQTTProperties* props); 来看一下具体的用法： 12345678910111213141516171819202122232425int disc_finished = 0;int rc;MQTTAsync_disconnectOptions disc_opts = MQTTAsync_disconnectOptions_initializer;disc_opts.onSuccess = onDisconnect;disc_opts.onFailure = onDisconnectFailure;if ((rc = MQTTAsync_disconnect(client, &amp;disc_opts)) != MQTTASYNC_SUCCESS)&#123; printf(&quot;Failed to start disconnect, return code %d\\n&quot;, rc); rc = EXIT_FAILURE; goto destroy_exit;&#125;void onDisconnectFailure(void* context, MQTTAsync_failureData* response)&#123; printf(&quot;Disconnect failed, rc %d\\n&quot;, response-&gt;code); disc_finished = 1;&#125;void onDisconnect(void* context, MQTTAsync_successData* response)&#123; printf(&quot;Successful disconnection\\n&quot;); disc_finished = 1;&#125;while (!disc_finished)&#123;...&#125; 2.6 获取连接状态​ 如果客户端喝服务器处于连接状态啧返回true，否则返回false。 同步客户端：LIBMQTT_API int MQTTClient_isConnected(MQTTClient handle); 异步客户端：LIBMQTT_API int MQTTAsync_isConnected(MQTTAsync handle); 2.7 订阅主题​ 在订阅主题上，同步客户端喝异步客户端的差别就是异步客户端可以将订阅动作的结果放到异步回调函数中处理，而同步客户端没有这个功能。 2.7.1 同步客户端订阅1LIBMQTT_API int MQTTClient_subscribe(MQTTClient handle, const char* topic, int qos); 只需要传入客户端句柄、订阅的主题以及消息质量即可： 12345678910#define TOPIC &quot;MQTT Examples&quot;#define QOS 1int rc;if ((rc = MQTTClient_subscribe(client, TOPIC, QOS)) != MQTTCLIENT_SUCCESS)&#123; printf(&quot;Failed to subscribe, return code %d\\n&quot;, rc); rc = EXIT_FAILURE;&#125; 2.7.2 异步客户端订阅12LIBMQTT_API int MQTTAsync_subscribe(MQTTAsync handle, const char* topic, int qos, MQTTAsync_responseOptions* response); 可以看到多了一个参数叫做响应操作，指向的就是对订阅操作动作的响应回调函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263typedef struct MQTTAsync_responseOptions&#123; /** The eyecatcher for this structure. Must be MQTR */ char struct_id[4]; /** The version number of this structure. Must be 0 or 1 * if 0, no MQTTV5 options */ int struct_version; /** * A pointer to a callback function to be called if the API call successfully * completes. Can be set to NULL, in which case no indication of successful * completion will be received. */ MQTTAsync_onSuccess* onSuccess; /** * A pointer to a callback function to be called if the API call fails. * Can be set to NULL, in which case no indication of unsuccessful * completion will be received. */ MQTTAsync_onFailure* onFailure; /** * A pointer to any application-specific context. The * the &lt;i&gt;context&lt;/i&gt; pointer is passed to success or failure callback functions to * provide access to the context information in the callback. */ void* context; /** * A token is returned from the call. It can be used to track * the state of this request, both in the callbacks and in future calls * such as ::MQTTAsync_waitForCompletion. */ MQTTAsync_token token; /** * A pointer to a callback function to be called if the API call successfully * completes. Can be set to NULL, in which case no indication of successful * completion will be received. */ MQTTAsync_onSuccess5* onSuccess5; /** * A pointer to a callback function to be called if the API call successfully * completes. Can be set to NULL, in which case no indication of successful * completion will be received. */ MQTTAsync_onFailure5* onFailure5; /** * MQTT V5 input properties */ MQTTProperties properties; /* * MQTT V5 subscribe options, when used with subscribe only. */ MQTTSubscribe_options subscribeOptions; /* * MQTT V5 subscribe option count, when used with subscribeMany only. * The number of entries in the subscribe_options_list array. */ int subscribeOptionsCount; /* * MQTT V5 subscribe option array, when used with subscribeMany only. */ MQTTSubscribe_options* subscribeOptionsList;&#125; MQTTAsync_responseOptions;#define MQTTAsync_responseOptions_initializer &#123; &#123;&#x27;M&#x27;, &#x27;Q&#x27;, &#x27;T&#x27;, &#x27;R&#x27;&#125;, 1, NULL, NULL, 0, 0, NULL, NULL, MQTTProperties_initializer, MQTTSubscribe_options_initializer, 0, NULL&#125; 用法： 1234567891011121314#define TOPIC &quot;MQTT Examples&quot;#define QOS 1MQTTAsync_responseOptions opts = MQTTAsync_responseOptions_initializer;int rc;opts.onSuccess = onSubscribe;opts.onFailure = onSubscribeFailure;opts.context = client;if ((rc = MQTTAsync_subscribe(client, TOPIC, QOS, &amp;opts)) != MQTTASYNC_SUCCESS)&#123; printf(&quot;Failed to start subscribe, return code %d\\n&quot;, rc); finished = 1;&#125; 消息到来后的处理是在设置回调函数的时候就设置了处理订阅消息的回调函数的： 12345678910111213int rc;if ((rc = MQTTAsync_setCallbacks(client, NULL, connlost, messageArrived, NULL)) != MQTTASYNC_SUCCESS)&#123; printf(&quot;Failed to set callback, return code %d\\n&quot;, rc); exit(EXIT_FAILURE);&#125;int messageArrived(void* context, char* topicName, int topicLen, MQTTAsync_message* m)&#123; /* not expecting any messages */ return 1;&#125; 我们就可以在这个回调函数中处理服务器下发过来的消息了。 2.8 发布消息​ 在发布消息上，同步客户端既支持同步机制也支持异步机制，同步机制就是必须要等到上一次的消息发布完成才能发布下一次的消息，异步则是支持一次处理多条消息；而异步客户端则只有异步机制。某种程度上来说，异步发布是兼容同步发布的。 ​ 发布消息有一个消息结构体，将消息的长度、消息内容、消息质量等抽象集成到了一起，这个结构体在同步客户端喝异步客户端也是不同的。 2.8.1 同步客户端的同步发布​ 消息结构体： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960typedef struct&#123; /** The eyecatcher for this structure. must be MQTM. */ char struct_id[4]; /** The version number of this structure. Must be 0 or 1 * 0 indicates no message properties */ int struct_version; /** The length of the MQTT message payload in bytes. */ int payloadlen; /** A pointer to the payload of the MQTT message. */ void* payload; /** * The quality of service (QoS) assigned to the message. * There are three levels of QoS: * &lt;DL&gt; * &lt;DT&gt;&lt;B&gt;QoS0&lt;/B&gt;&lt;/DT&gt; * &lt;DD&gt;Fire and forget - the message may not be delivered&lt;/DD&gt; * &lt;DT&gt;&lt;B&gt;QoS1&lt;/B&gt;&lt;/DT&gt; * &lt;DD&gt;At least once - the message will be delivered, but may be * delivered more than once in some circumstances.&lt;/DD&gt; * &lt;DT&gt;&lt;B&gt;QoS2&lt;/B&gt;&lt;/DT&gt; * &lt;DD&gt;Once and one only - the message will be delivered exactly once.&lt;/DD&gt; * &lt;/DL&gt; */ int qos; /** * The retained flag serves two purposes depending on whether the message * it is associated with is being published or received. * * &lt;b&gt;retained = true&lt;/b&gt;&lt;br&gt; * For messages being published, a true setting indicates that the MQTT * server should retain a copy of the message. The message will then be * transmitted to new subscribers to a topic that matches the message topic. * For subscribers registering a new subscription, the flag being true * indicates that the received message is not a new one, but one that has * been retained by the MQTT server. * * &lt;b&gt;retained = false&lt;/b&gt; &lt;br&gt; * For publishers, this indicates that this message should not be retained * by the MQTT server. For subscribers, a false setting indicates this is * a normal message, received as a result of it being published to the * server. */ int retained; /** * The dup flag indicates whether or not this message is a duplicate. * It is only meaningful when receiving QoS1 messages. When true, the * client application should take appropriate action to deal with the * duplicate message. */ int dup; /** The message identifier is normally reserved for internal use by the * MQTT client and server. */ int msgid; /** * The MQTT V5 properties associated with the message. */ MQTTProperties properties;&#125; MQTTClient_message; 发布消息的API: 12LIBMQTT_API int MQTTClient_publishMessage(MQTTClient handle, const char* topicName, MQTTClient_message* msg, MQTTClient_deliveryToken* dt); 最后个参数是发布消息的分发序号，在异步机制中起作用，同步机制中复制为NULL即可。来看一下具体的用法： 12345678910111213141516171819202122#define TOPIC &quot;MQTT Examples&quot;#define PAYLOAD &quot;Hello World!&quot;MQTTClient_message pubmsg = MQTTClient_message_initializer;MQTTClient_deliveryToken token;int rc;pubmsg.payload = PAYLOAD;pubmsg.payloadlen = (int)strlen(PAYLOAD);pubmsg.qos = QOS;pubmsg.retained = 0;if ((rc = MQTTClient_publishMessage(client, TOPIC, &amp;pubmsg, &amp;token)) != MQTTCLIENT_SUCCESS)&#123; printf(&quot;Failed to publish message, return code %d\\n&quot;, rc); exit(EXIT_FAILURE);&#125;printf(&quot;Waiting for up to %d seconds for publication of %s\\n&quot; &quot;on topic %s for client with ClientID: %s\\n&quot;, (int)(TIMEOUT/1000), PAYLOAD, TOPIC, CLIENTID);rc = MQTTClient_waitForCompletion(client, token, TIMEOUT);printf(&quot;Message with delivery token %d delivered\\n&quot;, token); 2.8.2 同步客户端的异步发布​ 消息包喝分发序号以及发布API就不多说了，区别在于用异步发布的时候，在设置回调函数的时候需要将发布动作的回调函数指定： 123456789101112131415MQTTClient_deliveryToken deliveredtoken;int rc;if ((rc = MQTTClient_setCallbacks(client, NULL, connlost, msgarrvd, delivered)) != MQTTCLIENT_SUCCESS)&#123; printf(&quot;Failed to set callbacks, return code %d\\n&quot;, rc); rc = EXIT_FAILURE; goto destroy_exit;&#125; void delivered(void *context, MQTTClient_deliveryToken dt)&#123; printf(&quot;Message with token value %d delivery confirmed\\n&quot;, dt); deliveredtoken = dt;&#125; 发布消息还是一样需要对消息包结构体进行赋值然后调用API发布出去： 123456789101112MQTTClient_message pubmsg = MQTTClient_message_initializer;int rc;pubmsg.payload = PAYLOAD;pubmsg.payloadlen = (int)strlen(PAYLOAD);pubmsg.qos = QOS;pubmsg.retained = 0;deliveredtoken = 0;if ((rc = MQTTClient_publishMessage(client, TOPIC, &amp;pubmsg, &amp;token)) != MQTTCLIENT_SUCCESS)&#123; printf(&quot;Failed to publish message, return code %d\\n&quot;, rc); rc = EXIT_FAILURE;&#125; 但是异步机制下如果发布没有成功的话，是不会进入回调函数中的，而异步客户端则有对发布失败的回调处理。 2.8.3 异步客户端发布​ 在异步客户端中，它既支持同步客户端的异步机制中的分发回调函数处理，也支持将发布消息成功和失败的回调处理器，它将这一操作放到了响应操作结构体中： 1MQTTAsync_responseOptions 通过对相应操作机构体的赋值以及发送消息的API调用，来进行回调处理设置： 1234567891011121314151617181920212223242526272829303132MQTTAsync client = (MQTTAsync)context;MQTTAsync_responseOptions opts = MQTTAsync_responseOptions_initializer;MQTTAsync_message pubmsg = MQTTAsync_message_initializer;int rc;printf(&quot;Successful connection\\n&quot;);opts.onSuccess = onSend;opts.onFailure = onSendFailure;opts.context = client;pubmsg.payload = PAYLOAD;pubmsg.payloadlen = (int)strlen(PAYLOAD);pubmsg.qos = QOS;pubmsg.retained = 0;if ((rc = MQTTAsync_sendMessage(client, TOPIC, &amp;pubmsg, &amp;opts)) != MQTTASYNC_SUCCESS)&#123; printf(&quot;Failed to start sendMessage, return code %d\\n&quot;, rc); exit(EXIT_FAILURE);&#125;void onSendFailure(void* context, MQTTAsync_failureData* response)&#123; MQTTAsync client = (MQTTAsync)context; printf(&quot;Message send failed token %d error code %d\\n&quot;, response-&gt;token, response-&gt;code);&#125;void onSend(void* context, MQTTAsync_successData* response)&#123; MQTTAsync client = (MQTTAsync)context; printf(&quot;Message with token value %d delivery confirmed\\n&quot;, response-&gt;token);&#125; 3. 示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#include &quot;mqtt_iot.h&quot;#include &quot;src/MQTTClient.h&quot; //需要在系统中提前安装好MQTT，可以参考#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;errno.h&gt;#define ADDRESS &quot;tcp://xxx:1883&quot; //根据 MQTT 实际主机地址调整#define CLIENTID &quot;xxx&quot;#define USERNAME &quot;xxx&quot;#define PASSWORD &quot;xxx&quot;#define QOS 0#define TIMEOUT 10000L#define PUB_TOPIC &quot;xxx&quot; #define SUB_TOPIC &quot;xxx&quot; extern void set_temp_humi_data(unsigned short value);volatile MQTTClient_deliveryToken deliveredtoken;pthread_t threads[2];sem_t discon_sem;int pubmsg_d = -1;int submsg_d = -1;msgbuf subMsg = &#123;1, 0&#125;;msgbuf pubMsg = &#123;2, 0&#125;;MQTTClient client; //定义一个MQTT客户端clientMQTTClient_connectOptions conn_opts = MQTTClient_connectOptions_initializer;//传递给MQTTClient_setCallbacks的回调函数，消息发送成功后，调用此回调函数void delivered(void *context, MQTTClient_deliveryToken dt)&#123; printf(&quot;Message with token value %d delivery confirmed\\n&quot;, dt); deliveredtoken = dt;&#125;//传递给MQTTClient_setCallbacks的回调函数 消息到达后，调用此回调函数 int msgarrvd(void *context, char *topicName, int topicLen, MQTTClient_message *message)&#123; printf(&quot;Message arrived\\n&quot;); printf(&quot; topic: %s\\n&quot;, topicName); printf(&quot; message: %.*s\\n&quot;, message-&gt;payloadlen, (char*)message-&gt;payload); unsigned short value = 0; unsigned short len = message-&gt;payloadlen; char *buf = (char*)message-&gt;payload; for(unsigned short i=0; i&lt;len; i++) &#123; if(buf[i] == &#x27;\\0&#x27;) break; if(buf[i]&lt;=&#x27;9&#x27; &amp;&amp; buf[i]&gt;=&#x27;0&#x27;) value = value*10 + buf[i] - &#x27;0&#x27;; &#125; set_temp_humi_data(value); MQTTClient_freeMessage(&amp;message); MQTTClient_free(topicName); return 1; &#125;//传递给MQTTClient_setCallbacks的回调函数 连接异常断开后调用此回调函数 void connlost(void *context, char *cause)&#123; printf(&quot;\\nConnection lost\\n&quot;); printf(&quot; cause: %s\\n&quot;, cause);&#125;//实现MQTT的发布 void *mqtt_publish(void *argv)&#123; MQTTClient_message pubmsg = MQTTClient_message_initializer; MQTTClient_deliveryToken token; char data[4]; int rc; pubmsg.qos = QOS; pubmsg.retained = 0; while(1) &#123; int res = msgrcv(pubmsg_d, &amp;pubMsg, sizeof(pubMsg.value), 0, IPC_NOWAIT); if(res &lt; 0) continue; &#123; printf(&quot;Publish: %d\\n&quot;, pubMsg.value); sprintf(data, &quot;%d&quot;, pubMsg.value); pubmsg.payload = data; pubmsg.payloadlen = 4; if ((rc = MQTTClient_publishMessage(client, PUB_TOPIC, &amp;pubmsg, &amp;token)) != MQTTCLIENT_SUCCESS) &#123; printf(&quot;Failed to publish message, return code %d\\n&quot;, rc); break; &#125; rc = MQTTClient_waitForCompletion(client, token, TIMEOUT); printf(&quot;Message with delivery token %d delivered\\n&quot;, token); &#125; &#125; if ((rc = MQTTClient_disconnect(client, 10000)) != MQTTCLIENT_SUCCESS) //断开和服务器的连接 &#123; printf(&quot;Failed to disconnect, return code %d\\n&quot;, rc); &#125; pthread_exit(&amp;threads[PubThread]); return NULL; &#125;int mqtt_disconnect(void)&#123; int rc = EXIT_SUCCESS; if ((rc = MQTTClient_disconnect(client, 10000)) != MQTTCLIENT_SUCCESS) //断开和服务器的连接 &#123; printf(&quot;Failed to disconnect, return code %d\\n&quot;, rc); rc = EXIT_FAILURE; &#125; else &#123; printf(&quot;MQTT disconnect success\\n&quot;); MQTTClient_destroy(&amp;client); &#125; return rc;&#125;int mqtt_iot(void)&#123; int rc = EXIT_SUCCESS; if ((rc = MQTTClient_create(&amp;client, ADDRESS, CLIENTID, MQTTCLIENT_PERSISTENCE_NONE, NULL)) != MQTTCLIENT_SUCCESS) &#123; printf(&quot;Failed to create client, return code %d\\n&quot;, rc); goto exit; &#125; //设置回调函数， if ((rc = MQTTClient_setCallbacks(client, NULL, connlost, msgarrvd, delivered)) != MQTTCLIENT_SUCCESS) &#123; printf(&quot;Failed to set callbacks, return code %d\\n&quot;, rc); goto destroy_exit; &#125; conn_opts.username = USERNAME; conn_opts.password = PASSWORD; conn_opts.keepAliveInterval = 60; conn_opts.cleansession = 1; //连接服务器 if ((rc = MQTTClient_connect(client, &amp;conn_opts)) != MQTTCLIENT_SUCCESS) &#123; printf(&quot;Failed to connect, return code %d\\n&quot;, rc); goto destroy_exit; &#125; //订阅主题 if ((rc = MQTTClient_subscribe(client, SUB_TOPIC, QOS)) != MQTTCLIENT_SUCCESS) &#123; printf(&quot;Failed to subscribe, return code %d\\n&quot;, rc); goto destroy_exit; &#125; // 初始化信号量 if(sem_init(&amp;discon_sem, 1, 0) != 0) &#123; printf(&quot;Failed to init semaphore\\n&quot;); return -1; &#125; // 创建队列 pubmsg_d = msgget(0x1234, IPC_CREAT); submsg_d = msgget(0x5678, IPC_CREAT); if(pubmsg_d == -1 || submsg_d==-1) &#123; printf(&quot;Failed to create a mqtt message, pubid:%d, subid:%d\\n&quot;, pubmsg_d, submsg_d); return -1; &#125; else &#123; printf(&quot;Publish message id: %d\\n&quot;, pubmsg_d); printf(&quot;Subscribe message id: %d\\n&quot;, submsg_d); &#125; printf(&quot;MQTT connect success, press &#x27;Q&#x27; or &#x27;q&#x27; to disconnect mqtt server\\n&quot;); return 0;destroy_exit: MQTTClient_destroy(&amp;client); //释放客户端的资源 return -1; exit: return -1;&#125;","tags":[{"name":"Linux","slug":"Linux","permalink":"http://slhking.github.io/tags/Linux/"}]},{"title":"【嵌入式Linux应用】温湿度监控系统——绘制温湿度折线图","date":"2022-07-01T13:56:02.000Z","path":"2022/07/01/LinuxApp-4-TempHumiChart/","text":"1. 概述​ 本篇的主要内容是使用SquareLine Studio绘制一个显示温湿度曲线图的表格，将其移植到100ASK STM32MP157开发板上显示，效果图如图所示： 2. 使用SquareLine Studio绘制UI​ 我们先使用SquareLine Studio绘制要显示的UI的草图，首先打开这个工具，点击Create，设置好工程名、分辨率和颜色深度后点击绿色按钮CREATE： 然后就进入了UI绘制界面，我们先将工程到处的路径设置好： 设置好之后点击绿色按钮APPLY CHANGES应用设置。 2.1 基本控件​ 本篇绘制的界面比较简单，只用到了LVGL的表格Chart和滑动条Slider，表格用来绘制温湿度数值的折线图，滑动条用来显示温湿度数值： 各个窗体的作用描述如下： 序号 名称 描述 ① Hierarchy-层级；Animations-动画 层级是用来表示UI中的控件的layout布局；动画则是在添加不同screen切换的动画效果 ② Widgets-窗体 里面是LVGL的基础控件 ③ Assets-资源；Console-终端 资源里面表示的是我们导入的外部的资源，比如图片、动画等；终端则是显示的是在这个工具中的操作在终端下的命令 ④ 控件设置窗体 用来设置选中的空间的参数，比如名称、初始值、颜色这些 ④ EVENTS-事件窗 用来添加选中空间需要的事件，比如VALUE_CHANGED这些的事件 上图中的两个slider和chart的大小、位置就是根据④中的设置来改变调整的。 2.2 调整chart 名称：因为目前就一个screen，也只需要一个chart，所以取名就叫chart； 大小：根据屏幕分辨率，还考虑到后期可能会在边缘加上刻度，所以不能把char的大小设置为和屏幕一样大，我们还是弄小一点，设置成800*400； 对齐方式：这个地方设置的是控件在屏幕上的对齐方式，是居中显示还是左上显示还是怎样，我们期望我们的表格是屏幕居中显示的，所以就设置为CENTER； 位置：控件的位置值设置的是控件中心对称点的位置，所以chart要居中显示的话，chart的中心对称点就应该是屏幕的中心对称点，位置(0, 0); 其它的设置先暂时不弄 2.3 调整slider基本属性 名称：根据我们的项目，我们要显示两个东西，温度和湿度，所以两个slider分别取名叫做tempSlider和humiSlider； 大小：根据屏幕和表格大小调整，这里设置的是15*390； 对齐方式：我们是以chart位中心来设置位置的，所以slider的对齐方式要和chart的一样，设置为CENTER； 位置：根据表格的宽度和高度设置，这里设置的是(-390， 0)和(390， 0); 范围：温度的范围设置为[-20, 60]，湿度设置为[0, 100]，这个根据常识设置； 模式：有普通模式、对称模式和范围模式，这里设置为普通模式即可，其它模式大家可以自己在studio中探索； 初值：设置为0； 左值：同样设置为0，只有在范围模式下有用； 这样设置后slider的效果如下图： 2.4 优化slider显示效果 设置主体背景颜色：主体背景就是整条滑动条的底色，这里设置为白色，RGB(255，255，255): 设置方向背景颜色：方向背景颜色就是这里增量方向的背景颜色，这里设置为渐变色，温度从白色渐变到红色；湿度从白色渐变到蓝色： 设置指向标颜色：指向标就是滑动条上的那个实心圆，我们可以用相同的放射将其设置为纯色或者渐变色： 2.4 导出UI源文件​ 本次项目的效果比较简单，没有用到很复杂的控件设置(复杂的设置SquareLine也设置不了)，也没有用到事件这些，现在九江这个UI的源文件导出去添加到模拟器，因为在模拟器上我们可以轻松快速的编辑UI的详细设置且看到效果，在模拟器上编辑的差不多了再移植到Linux中。 ​ 导出和移植到模拟器在上一篇已经讲过了，这里就不再重复讲了。 3. 使用模拟器丰富UI​ 我们的表格现在还只是一张空的表格，我们还希望它能显示两条折线、X轴和Y轴显示刻度值，根据官方的例程和手册，这里将补充用到的LVGL接口函数总结下： 函数名称 参数 作用 lv_chart_set_div_line_count lv_obj_t * obj：控件对象；uint8_t hdiv：纵坐标平均点数uint8_t vdiv：横坐标平均点数 设置表格的横纵坐标显示点数 lv_chart_set_point_count lv_obj_t * obj：控件对象；uint16_t cnt：绘制点数 设置表格中显示数据的点数，比如设置成20，那么整张表就最多只绘制出20个点出来 lv_chart_set_range lv_obj_t * obj：控件对象；lv_chart_axis_t axis：坐标轴lv_coord_t min&#x2F;max:坐标轴的最大最小值 设置表格的坐标轴数值范围，坐标轴LV_CHART_AXIS_PRIMARY_Y表示表格左侧Y轴；LV_CHART_AXIS_SECONDARY_Y表示表格右侧Y轴；LV_CHART_AXIS_PRIMARY_X表示表格下方X轴；LV_CHART_AXIS_SECONDARY_X表示表格上方X轴 lv_chart_add_series lv_obj_t * obj：控件对象；lv_color_t color：折线颜色；lv_chart_axis_t axis：折线对齐的坐标轴 返回一个从属于对象表格的折线对象，可以通过设置折线对象的值来让其显示到对象表格中 lv_chart_set_axis_tick lv_obj_t * obj：控件对象；lv_chart_axis_t axis：坐标轴；lv_coord_t major_len：主刻度长度；lv_coord_t minor_len：副刻度长度;lv_coord_t major_cnt:主刻度点数；lv_coord_t minor_cnt：副刻度点数；bool label_en:是否显示主刻度数值;lv_coord_t draw_size：刻度尺的大小； 根据参数设置X&#x2F;Y轴的刻度 这里设置的是： 1234567891011121314// 全局变量:折线对象lv_chart_series_t* temp;lv_chart_series_t* humi;// 表格的设置lv_chart_set_div_line_count(ui_chart, 121, 21);lv_chart_set_point_count(ui_chart, 50);lv_chart_set_range(ui_chart, LV_CHART_AXIS_PRIMARY_Y, -20, 60);lv_chart_set_range(ui_chart, LV_CHART_AXIS_SECONDARY_Y, 0, 120);temp = lv_chart_add_series(ui_chart, lv_color_make(0xFF, 0x00, 0x00), LV_CHART_AXIS_PRIMARY_Y);humi = lv_chart_add_series(ui_chart, lv_color_make(0x00, 0x80, 0x00), LV_CHART_AXIS_SECONDARY_Y);lv_chart_set_axis_tick(ui_chart, LV_CHART_AXIS_PRIMARY_X, 10, 5, 20, 1, true, 50);lv_chart_set_axis_tick(ui_chart, LV_CHART_AXIS_PRIMARY_Y, 10, 5, 9, 10, true, 50);lv_chart_set_axis_tick(ui_chart, LV_CHART_AXIS_SECONDARY_Y, 10, 5, 12, 10, true, 50); 模拟器上的显示： 需要注意的是，定义的折现对象全局变量要去ui.h里面声明，后面mqtt获取远程温湿度监测设备的温度的时候需要设置他们来在表格中显示： 123// ui.hextern lv_chart_series_t* temp;extern lv_chart_series_t* humi; 4. 移植UI到Linux​ 如何将UI源文件移植到Ubuntu进行交叉编译并且移植到的开发板上显示，前面的文章已经讲过方法了，这里就不多说了。 5. 总结​ 利用SquareLine可以很快的绘制比较好看的UI然后利用模拟器来完善，最终移植到Linux开发板上显示，整个过程比价复杂的是在SquareLine设置控件的基本属性，这需要我们慢慢的探索和熟悉这个工具；另外最重要的还是我们对LVGL本身的学习了解，才能在模拟器上丰富和完善UI草图；然后后面的移植操作就比较简单了。 ​ 下一步就是将mqtt移植到我们的这个UI工程里面来，通过mqtt获取云端数据然后在屏幕上显示温湿度监控子设备上传的数据。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://slhking.github.io/tags/Linux/"}]},{"title":"【嵌入式Linux应用】SquareLine Studio与LVGL模拟器","date":"2022-06-28T02:26:43.191Z","path":"2022/06/28/LinuxApp-3-SquareLineAndSimulator/","text":"1. 概述​ 本篇重点是讲LVGL的开发辅助工具，以及利用这些工具将LVGL制作UI之后移植到嵌入式Linux开发板上显示。 2. 软硬件平台​ 本次开发是在Windows10和Ubuntu下联合进行的，使用的嵌入式Linux开发板是百问网的STM32MP157开发板，LVGL的开发辅助工具如下： 名称 作用 链接 lv_port_win_visual_studio Windows下的visual studio工程，是lvgl在Windows下的模拟器，可以运行模拟显示例程UI或者自己制作的UI github地址 SquareLine Studio Windows下的LVGL布局工具以及代码生成器，可以生成python格式或者C&#x2F;C++格式的代码，IDE是eclipse，我们不需要下载eclipse，直接移植到ubuntu编译就好； SquareLine Studio visual studio Windows下的微软开发的C&#x2F;C++、C#等语言的开发IDE vs 注意1：lv_port_win_visual_studio的安装一定要根据github下的README进行，不然会缺少内容。 注意2：SquareLine Studio个人免费且绑定机器码，一个账号只能在一台机器上使用这个工具；商用是收费的。 3. visual studio编译运行模拟器​ 当我们使用git将lv_port_win_visual_studio克隆到本地之后，在本地的打开visual studio工程： 然后就会进入visual studio的开发界面，我们可以先编译一下检查下环境是否有问题。如果你遇到编译后提示找不到stdint.h这些头文件等，去工程属性中的VC++目录中的包含目录和库目录中将如下图所示的头文件和库文件添加进来： 包含目录 库目录 选好这些后就可以编译通过了，也就是可以成功的生成解决方案了，然后我们点击执行简单看下效果： 4. SquareLine Studio绘制UI​ 这个工具的安装步骤就不多说了，唯一值得注意的就是要自己注册一个账号然后会给你生成和这台机器绑定的License，直接选择它使用就好。 4.1 绘制ui​ 当我们运行这个studio的时候，一开始会让我们是选择创建一个工程还是打开一个示例，我们就先跑一跑它的示例吧： 点击CREATE后就来到了这样一个界面： 可以看到这个工具可以拖拽很多LVGL内核的控件、导入图片、添加事件等到里面来，用以绘制UI，有点像Qt，这样就方便我们构建我们的UI草图。 4.2 设置工程属性适配屏幕但是要绘制成适合我们屏幕的参数的UI，还要设置工程属性Project Settings： 这里主要关心的就两个地方，一个是UI分辨率，要根据自己屏幕的分辨率来设置，后面的颜色深度也是根据自己的屏幕接口是RGB565这样的16bit的颜色还是怎样的，反正都要根据自己的实际情况来修改，比如这里使用的是百问网的7寸屏幕，分辨率是1024*600，颜色是RGB565 16bit的；接着是导出工程的属性，这里支持两种语言，一个是micropython，另一个是C&#x2F;C++，我们是要在C下开发UI的，所以选择C&#x2F;C++，最后是导出工程或者文件的路径，根据自己的实际情况选择就是： 设置好之后点击APPLY CHANGES来应用设置。 4.3 导出ui的源文件​ 修改了分辨率之后，示例的ui布局肯定就乱了不好看了，但是现在不重要，我们只是要来熟悉这个工具而已，我们先按快捷键CTRL+S保存工程，然后在菜单栏的EXPORT选择导出文件： 如果是导出工程的话，会将lvgl和lv_drivers这两个官方源码一起导出，我们实际上不管是在visual studio还是后面会移植到的Ubuntu，在之前的那片《移植LVGL到Ubuntu和嵌入式Linux开发板》已经将官方源码进行了移植了，所以这里只需要这个工具制作UI后生成的UI的源码即可，所以这里选择的是导出文件，它导出成功后会弹出提示告诉我们导出成功了： 我们就可以去上一步选择的导出路径那里找到导出的文件了： 我们只需要把这个文件夹下的文件移植到工程里进行调用编译，即可显示我们用SquareLine Studio绘制的UI。 5. 移植UI到visual studio模拟器5.1 复制源文件到模拟器工作区间​ 我们将刚才导出的文件全选，然后选择复制： 再回到visual studio的模拟器工程，将文件粘贴到工程的编译项： 要注意粘贴后的这些文件并不会直接粘贴到模拟器所在的文件夹，只是粘贴到了这个visual studio工作空间： 5.2 指定ui源文件所在目录且编译运行​ 这时候工作区间由于我们没有指定粘贴过来的这些头文件所在路径，所以编译的话会编译不过，报错提示找不到头文件，所以我们就要将我们刚才在SquareLine Studio指定的导出路径添加到visual studio的包含路径里面去： 然后我们编辑LVGL.Simulator.cpp，将ui.h这个头文件包含进去，并且注释掉原本的示例，调用ui.c里面定义的ui.h里面声明的ui_init函数： 编辑好之后保存，然后清理下解决方案后再重新生成解决方案： 编译生成没有错误： 然后点击开始执行，观察效果： 就看到了我们在SquareLine Studio中绘制的UI（这里是示例）在模拟器上显示运行了： 6. 移植UI到嵌入式Linux开发板​ 在《【嵌入式Linux应用】移植LVGL到Linux开发板》文章中我们已经在虚拟机Ubuntu上创建了一个以LVGL官方示例的嵌入式Linux LVGL工程，我们现在要做的就是将自己在Windows下的SquareLine Studio中绘制的UI移植到这个工程中，然后编译烧写到开发板上来显示。 6.1 上传导出的ui源文件和头文件​ 我们可以可以通过很多方式将SquareLine导出的ui源文件和头文件复制或者下载到Ubuntu中的lvgl工程中去，这里的做法就是去工程里新建一个ui文件夹，来存放导出的这些文件： 12book@100ask:~$ cd /home/book/workspace/lvgl_demobook@100ask:~/workspace/lvgl_demo$ mkdir ui 然后使用Mobaxterm的ssh登录虚拟机，将文件下载到ui里面去： 6.2 编辑main.c​ 调用方法和模拟器里面类似，也是添加头文件然后调用ui_init函数，不过差别是ubuntu工程里面要明确头文件所在目录，不然无法找到头文件： 1#include &quot;ui/ui.h&quot; 然后去main函数中调用ui_init： 6.3 Makefile我们要将ui目录下的源文件和头文件添加到编译中，就要仿照工程目录下的Makefile中添加lvgl官方源码的那样： 在用到的子目录中创建该子目录的.mk文件，仿照lvgl.mk或者lv_drivers.mk的写法： 来写ui子目录的.mk： 1book@100ask:~/workspace/lvgl_demo$ touch ui/ui.mk 然后将这个ui.mk添加到工程根目录所在的Makefile中： 然后执行make： 1book@100ask:~/workspace/lvgl_demo$ make -j8 由于运行的是SquareLine Studio的那个有点复杂的示例，它用到了26号字体，但是我们lv_conf.h里面并没有使能使用，所以编译报错了，所以我们需要在lv_conf.h里面使能这个字体： 然后重新执行make就没有报错了。 6.4 开发板运行示例ui​ 开发板挂载以及拷贝demo到开发板这个过程就不再多说了： 12345678#开发板先挂载[root@100ask:~]# mount -t nfs -o nolock,vers=3 192.168.3.14:/home/book/nfs_rootfs /mnt#虚拟机将编译出来的可执行文件copy到共享目录book@100ask:~/workspace/lvgl_demo$ cp demo ~/nfs_rootfs#开发板将demo从共享目录copy到本地[root@100ask:~]# cp /mnt/demo ./#开发板运行demo[root@100ask:~]# ./demo 就可以看到示例ui也在开发板上的屏幕显示出来了。 7. 总结​ 从本篇的快速体验这些LVGL开发辅助工具，大家应该能够体会到SquareLine Studio和模拟器给我们使用LVGL开发自己的显示产品有多大的助益了，不过这个软件商用收费挺高的，期望国内会有大牛公司能早点做出类似效果的工具。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://slhking.github.io/tags/Linux/"},{"name":"LVGL","slug":"LVGL","permalink":"http://slhking.github.io/tags/LVGL/"}]},{"title":"【嵌入式Linux应用】初步移植MQTT到Ubuntu和Linux开发板","date":"2022-06-21T09:53:26.000Z","path":"2022/06/21/LinuxApp-2-PortingMQTTForSTM32MP157/","text":"1. 概述​ 本篇主要是记录将MQTT移植安装到百问网STM32MP157开发板上，并且是跑一下MQTT的一个例程来验证，要完成本次移植安装，必须要保证电脑和开发板都能上网。。 2. 软件平台​ 本次使用的是Ubuntu18.04，是由百问网提供的，并且是按照他们的手册搭建好了交叉编译环境，花了一点时间将Linux内核编译好之后才进行的LVGL移植，本次移植必须搭建好嵌入式Linux的交叉编译环境且内核也必须编译好，否则无法完成移植。 3. 移植所需要的资源​ 本次实验主要是要将paho mqtt的官方库克隆到本地pc，将其编译后得到链接库，然后安装到本地pc以及开发板上，这样才能运行paho mqtt编译后的可执行文件，paho mqtt的官方仓库地址： 1https://github.com/eclipse/paho.mqtt.c.git 在Ubuntu的/home/book目录下新建一个工作区用来保存工程和开发资料： 123cd /home/bookbook@100ask:~$ mkdir workspace &amp;&amp; cd workspacebook@100ask:~/workspace$ mkdir mqtt &amp;&amp; cd mqtt 在/home/book/workspace/mqtt下讲paho mqtt的仓库克隆下来： 1book@100ask:~/workspace/mqtt$ git clone https://github.com/eclipse/paho.mqtt.c.git 等待下载完成： 1234567Cloning into &#x27;paho.mqtt.c&#x27;...remote: Enumerating objects: 11797, done.remote: Counting objects: 100% (1741/1741), done.remote: Compressing objects: 100% (485/485), done.remote: Total 11797 (delta 1272), reused 1628 (delta 1204), pack-reused 10056Receiving objects: 100% (11797/11797), 9.27 MiB | 6.78 MiB/s, done.Resolving deltas: 100% (8385/8385), done. 4. 安装mqtt到ubuntu4.1 修改Makefile适配GCC环境进入刚才克隆下来的这个仓库paho.mqtt.c，修改Makefile： 12book@100ask:~/workspace/mqtt$ cd paho.mqtt.c/book@100ask:~/workspace/mqtt/paho.mqtt.c$ vim Makefile 进入vim后如果要显示行号首先按下键盘的ESC键，然后键入:set nu就可以显示行号了： 我们需要关注的有两个地方： 编译器：Makefile的126行 库安装路径：Makefile的70行 如果我们只需要在Ubuntu里面使用paho mqtt的话，这些都不需要改变，直接在/home/book/workspace/mqtt/paho.mqtt.c目录下执行下面两条命令即可： 12makesudo make install 4.2 编译和安装库文件 执行make后会在当前目录下创建一个build目录，源码和例程编译出来的可执行文件都在里面，然后再执行sudo make install： 这条指令会将mqtt程序依赖的库文件安装到/usr/local下的bin、lib、include和share下。 4.3 体验测试​ 我们可以将官方的示例代码copy过来，改成我们自己的配置，比如iot的url、客户端ID、用户名和密码这些，改成我们自己的mqtt服务器的信息测试下。 ​ 我们去/home/book/workspace目录下新建一个测试工程，取名就叫’mqtt_test’吧： 123book@100ask:~/workspace$ cd /home/book/workspacebook@100ask:~/workspace$ mkdir mqtt_testbook@100ask:~/workspace$ cd mqtt_test 将paho.mqtt.c下的src和sample里面的随意一个示例代码copy过来： 12book@100ask:~/workspace/mqtt_test$ cp -r /home/book/workspace/mqtt/paho.mqtt.c/src ./book@100ask:~/workspace/mqtt_test$ cp src/samples/MQTTAsync_subscribe.c ./ 我们这里copy的是MQTTAsync开头的例程，其表示的是MQTT的异步通信收发，依赖的库是libpaho-mqtt3a，如果是MQTTClient开头的，依赖的库就是libpaho-mqtt3c，如果自己写代码还会用到SSL的话，依赖的库就会变成libpaho-mqt3cs或者ibpaho-mqtt3as。如何确定使用的是Async还是Client呢，根据自己写的代码里面包含的头文件是MQTTAsync.h还是MQTTClient.h，比如我刚才copy的例程MQTTAsync_subscribe.c： ​ 我们现在来修改这个示例代码。首先是头文件MQTTAsync.h，我们需要指定路径，不然在当前目录下是找不到这个头文件的，我们已经将这个头文件所在的官方源文件文件夹srccopy过来了，所以只需要改成： 1#include &quot;src/MQTTAsync.h&quot; 然后修改url和客户端id这些信息，原来的参数是这样的： 12332 #define ADDRESS &quot;tcp://mqtt.eclipseprojects.io:1883&quot;33 #define CLIENTID &quot;ExampleClientSub&quot;34 #define TOPIC &quot;MQTT Examples&quot; 我们要修改ADDRESS和CLIENTID以及订阅的TOPIC，还要添加阿里云物联网平台设备的用户名USERNAME和密码PASSWORD： 鉴于阿里云物联网平台的要求，我们需要将连接控制包的keepAliveInterval设置位60，并且对控制包的用户名username和密码password赋值为我们宏定义的值： 123456789/* void connlost(void *context, char *cause) */ conn_opts.username = USERNAME;conn_opts.password = PASSWORD;conn_opts.keepAliveInterval = 60;/* int main(int argc, char* argv[]) */conn_opts.username = USERNAME;conn_opts.password = PASSWORD;conn_opts.keepAliveInterval = 60; 然后保存退出（ESC–&gt;:wq）。 ​ 编译修改号之后的MQTTAsync_subscribe.c： 123book@100ask:~/workspace/mqtt_test$ gcc MQTTAsync_subscribe.c -lpaho-mqtt3abook@100ask:~/workspace/mqtt_test$ lsa.out MQTTAsync_subscribe.c src 可以看到生成了一个a.out，我们执行整个文件： 1book@100ask:~/workspace/mqtt_test$ ./a.out 如果连接成功了且订阅也成功了会打印如下信息： 这时候我们从阿里云服务器下发一条消息看看： 回到我们的终端看是否有收到消息： 这就说明我们在Ubuntu下已经成功移植了paho mqtt，接下来我们将它移植到Linux开发板上，这里使用的是百问网的100ASK STM32MP157开发板。 5. 移植mqtt到linux开发板5.1 查看自己的编译环境123456book@100ask:~/workspace/mqtt$ echo $ARCHarmbook@100ask:~/workspace/mqtt$ echo $CROSS_COMPILE arm-buildroot-linux-gnueabihf-book@100ask:~/workspace/mqtt$ echo $PATH/home/book/.vscode-server/bin/30d9c6cd9483b2cc586687151bcbcd635f373630/bin/remote-cli:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/home/book/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin:/home/book/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin:/home/book/100ask_stm32mp157_pro-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin 检查下编译器是否生效可用： 1book@100ask:~/workspace/mqtt$ arm-buildroot-linux-gnueabihf-gcc -v 5.2 修改Makefile 修改编译器 改成自己的编译器，比如这里将其改成：CC ?=arm-buildroot-linux-gnueabihf-gcc： 1book@100ask:~/workspace/mqtt$ cd /home/book/workspace/mqtt/paho.mqtt.c 再修改之前先将原先用gcc编译的clean清除掉： 123book@100ask:~/workspace/mqtt/paho.mqtt.c$ make cleanrm -rf build/output/*rm -rf build/ 然后去修改Makefile： 修改库安装路径 参考gcc下是将库安装到了&#x2F;user里面的，所以我们也要将路径指定到我们自己编译链下的usr中，比如百问网的工具链&#x2F;usr&#x2F;local就是如下所示 1/home/book/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/arm-buildroot-linux-gnueabihf 所以原本的 就改成下图所示的这样： 这里太长没有截图显示全，然后保存退出编辑。 5.3 编译源文件且安装库文件​ 在paHo.mqtt.c中再重新执行一遍下面的命令： 12book@100ask:~/workspace/mqtt/paho.mqtt.c$ makebook@100ask:~/workspace/mqtt/paho.mqtt.c$ sudo make install 5.4 安装库文件到开发板​ 在上一步make之后就生成了arm-gcc编译后的库文件.so文件，保存在paho.mqtt.c/build/output里面 我们将其复制到挂载共享目录/home/book/nfs_rootfs里面去，为了方便管理我们需要现在这个目录下创建一个文件夹来存放mqtt的库，取名就叫mqtt_lib吧: 123book@100ask:~$ cd nfs_rootfs/book@100ask:~/nfs_rootfs$ mkdir mqtt_libbook@100ask:~/nfs_rootfs$ cd mqtt_lib/ 我们把mqtt的库文件copy过去： 1book@100ask:~/workspace/mqtt/paho.mqtt.c$ sudo cp build/output/libpaho-mqtt3* ~/nfs_rootfs/mqtt_lib 接着将开发板的/mnt挂载到虚拟机的nfs_rootfs目录： 1mount -t nfs -o nolock,vers=3 192.168.50.12:/home/book/nfs_rootfs /mnt 使用install或者mv指令将/mnt/mqtt_lib中的所有mqtt库文件安装到开发板的/lib目录下： 1install /mnt/mqtt_lib/libpaho-mqtt3* /lib 5.5 重新编译测试文件12book@100ask:~$ cd /home/book/workspace/mqtt_testbook@100ask:~/workspace/mqtt_test$ arm-buildroot-linux-gnueabihf-gcc MQTTAsync_subscribe.c -lpaho-mqtt3a 将重新编译出来的执行文件a.out复制到nfs_rootfs中去： 1book@100ask:~/workspace/mqtt_test$ cp a.out ~/nfs_rootfs/ 然后回到开发板，将/mnt目录下的a.out复制到根目录，然后执行： 12# cp /mnt/a.out ./# ./a.out 可以看到，开发板也能成功的和阿里云物联网设备通过MQTT协议通信了，最后这里就不再下发数据测试了。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://slhking.github.io/tags/Linux/"}]},{"title":"【嵌入式Linux应用】移植LVGL到Linux开发板","date":"2022-06-21T06:23:57.000Z","path":"2022/06/21/LinuxApp-1-PortingLVGLForSTM32MP157/","text":"1. 概述​ 本篇主要是记录将LVGL移植到百问网STM32MP157开发板上，并且仅是跑一下LVGL的一些例程。 2. 软件平台​ 本次使用的是Ubuntu18.04，是由百问网提供的，并且是按照他们的手册搭建好了交叉编译环境，花了一点时间将Linux内核编译好之后才进行的LVGL移植，本次移植必须搭建好嵌入式Linux的交叉编译环境且内核也必须编译好，否则无法完成移植。 3. 移植所需要的资源​ 本次实验是从LVGL的官方仓库，移植了三个仓库： 名称 仓库地址 描述 lvgl https://github.com/lvgl/lvgl.git 包含了LVGL图形界面控件的源码以及少量例程 lv_drivers https://github.com/lvgl/lv_drivers.git 包含了驱动LVGL图形界面的驱动接口源代码 lv_demos https://github.com/lvgl/lv_demos.git LVGL的例程 lv_port_linux_frame_buffer https://github.com/lvgl/lv_port_linux_frame_buffer.git 适配有frame buffer的linux系统的接口 4. 移植步骤4.1 移植文件​ 首先在根目录创建一个文件夹用以存放官方的源码： 12book@100ask:~$ mkdir lvglbook@100ask:~$ cd lvgl 然后使用git命令，将前面提到的仓库克隆到本地： 1234book@100ask:~/lvgl$ git clone https://github.com/lvgl/lvgl.gitbook@100ask:~/lvgl$ git clone https://github.com/lvgl/lv_drivers.gitbook@100ask:~/lvgl$ git clone https://github.com/lvgl/lv_demos.gitbook@100ask:~/lvgl$ git clone https://github.com/lvgl/lv_port_linux_frame_buffer.git 因为仓库是在github上的，克隆可能会失败，多尝试几次。如果几个仓库都克隆成功了，那么在lvgl下用ls命令检查就能看到如下结果： 12book@100ask:~/lvgl$ lslv_demos lv_drivers lvgl lv_port_linux_frame_buffer 然后再去根目录下创建一个工作空间，在工作空间内创建一个lvgl的工程，我将其取名叫做lvgl_demo： 12345book@100ask:~/lvgl$ cdbook@100ask:~$ mkdir workspacebook@100ask:~$ cd workspacebook@100ask:~/workspace$ mkdir lvgl_demobook@100ask:~/workspace$ cd lvgl_demo 将根目录下的lvgl文件夹中的lvgl、lv_drivers和lv_port_linux_frame_buffer中的main.c与Makefile复制到lvgl_demo中： 12345678910book@100ask:~/workspace/lvgl_demo$ cp -r ~/lvgl/lvgl ./book@100ask:~/workspace/lvgl_demo$ cp -r ~/lvgl/lv_drivers ./book@100ask:~/workspace/lvgl_demo$ cp ~/lvgl/lv_port_linux_frame_buffer/main.c ./book@100ask:~/workspace/lvgl_demo$ cp ~/lvgl/lv_port_linux_frame_buffer/Makefile ./book@100ask:~/workspace/lvgl_demo$ ls -ltotal 16drwxrwxr-x 11 book book 4096 Jun 21 03:07 lv_driversdrwxrwxr-x 11 book book 4096 Jun 21 03:07 lvgl-rw-rw-r-- 1 book book 2350 Jun 21 03:07 main.c-rw-rw-r-- 1 book book 1812 Jun 21 03:07 Makefile 将lvgl中的lv_conf_template.h复制出来并且改名位lv_conf.h： 1book@100ask:~/workspace/lvgl_demo$ cp lvgl/lv_conf_template.h lv_conf.h 将lv_drivers中的lv_drv_conf_template.h复制出来并且改名为lv_drv_conf.h： 1book@100ask:~/workspace/lvgl_demo$ cp lv_drivers/lv_drv_conf_template.h lv_drv_conf.h 这样，我们的lvgl_demo的工程目录有如下的文件： 12345678book@100ask:~/workspace/lvgl_demo$ ls -ltotal 60-rw-rw-r-- 1 book book 24733 Jun 21 03:08 lv_conf.hdrwxrwxr-x 11 book book 4096 Jun 21 03:07 lv_drivers-rw-rw-r-- 1 book book 14940 Jun 21 03:10 lv_drv_conf.hdrwxrwxr-x 11 book book 4096 Jun 21 03:07 lvgl-rw-rw-r-- 1 book book 2350 Jun 21 03:07 main.c-rw-rw-r-- 1 book book 1812 Jun 21 03:07 Makefile 4.2 修改配置文件 修改lv_drv_conf.h ​ 修改这个文件的目的主要是为了使用linux下的frame buffer输出显示以及触控输入，需要将第11行的#if 0改成#if 1: 1book@100ask:~/workspace/lvgl_demo$ vim lv_drv_conf.h 如果在vim中显示文本的行数，只需要按下键盘上的ESC键，然后输入:set nu就能显示行数了，先讲第11行的改成#if 1，要编辑需要进入编辑模式，如果当前不是编辑模式，就按键盘上的i键进入编辑模式： 1210 /* clang-format off */11 #if 1 /*Set it to &quot;1&quot; to enable the content*/ 然后318~324行，将USE_FBDEV的值改为1，使能frame buffer设备： 12345678910315 /*-----------------------------------------316 * Linux frame buffer device (/dev/fbx)317 *-----------------------------------------*/318 #ifndef USE_FBDEV319 # define USE_FBDEV 1320 #endif321322 #if USE_FBDEV323 # define FBDEV_PATH &quot;/dev/fb0&quot;324 #endif 接着是441~461行，将USE_EVDEV使能，并且触控输入设备的名称要根据自己的板子实际情况更改： 123456789101112131415161718192021222324438 /*-------------------------------------------------439 * Mouse or touchpad as evdev interface (for Linux based systems)440 *------------------------------------------------*/441 #ifndef USE_EVDEV442 # define USE_EVDEV 1443 #endif444445 #ifndef USE_BSD_EVDEV446 # define USE_BSD_EVDEV 0447 #endif448449 #if USE_EVDEV || USE_BSD_EVDEV450 # define EVDEV_NAME &quot;/dev/input/event0&quot; /*You can use the &quot;evtest&quot; Linux tool to get the list of devices and test them*/451 # define EVDEV_SWAP_AXES 0 /*Swap the x and y axes of the touchscreen*/452453 # define EVDEV_CALIBRATE 0 /*Scale and offset the touchscreen coordinates by using maximum and minimum values for each axis*/454455 # if EVDEV_CALIBRATE456 # define EVDEV_HOR_MIN 0 /*to invert axis swap EVDEV_XXX_MIN by EVDEV_XXX_MAX*/457 # define EVDEV_HOR_MAX 4096 /*&quot;evtest&quot; Linux tool can help to get the correct calibraion values&gt;*/458 # define EVDEV_VER_MIN 0459 # define EVDEV_VER_MAX 4096460 # endif /*EVDEV_CALIBRATE*/461 #endif /*USE_EVDEV*/ 其它的地方暂时不用修改，然后按ESC退出编辑模式，输入:wq保存退出。 修改lv_conf.h 和lv_drv_conf.h一样需要将一开始的#if 0改成#if 1： 1214 /* clang-format off */15 #if 1 /*Set it to &quot;1&quot; to enable content*/ 接着是49~67行修改显存大小，可以使能LV_MEM_CUSTOM自己分配也可以自动分配，我选择的是自己分配显存： 123456789101112131415161718192048 /*1: use custom malloc/free, 0: use the built-in `lv_mem_alloc()` and `lv_mem_free()`*/49 #define LV_MEM_CUSTOM 150 #if LV_MEM_CUSTOM == 051 /*Size of the memory available for `lv_mem_alloc()` in bytes (&gt;= 2kB)*/52 #define LV_MEM_SIZE (10 * 1024U * 1024U) /*[bytes]*/5354 /*Set an address for the memory pool instead of allocating it as a normal array. Can be in external SRAM too.*/55 #define LV_MEM_ADR 0 /*0: unused*/56 /*Instead of an address give a memory allocator that will be called to get a memory pool for LVGL. E.g. my_malloc*/57 #if LV_MEM_ADR == 058 #undef LV_MEM_POOL_INCLUDE59 #undef LV_MEM_POOL_ALLOC60 #endif6162 #else /*LV_MEM_CUSTOM*/63 #define LV_MEM_CUSTOM_INCLUDE &lt;stdlib.h&gt; /*Header for the dynamic memory function*/64 #define LV_MEM_CUSTOM_ALLOC malloc65 #define LV_MEM_CUSTOM_FREE free66 #define LV_MEM_CUSTOM_REALLOC realloc67 #endif /*LV_MEM_CUSTOM*/ 随后是刷新时间，鉴于处理器的运算能力可以自己调整，像我这原本是30ms，都被我调整成了10ms： 1234580 /*Default display refresh period. LVG will redraw changed areas with this period time*/81 #define LV_DISP_DEF_REFR_PERIOD 10 /*[ms]*/8283 /*Input device read period in milliseconds*/84 #define LV_INDEV_DEF_READ_PERIOD 10 /*[ms]*/ 最后是比较关键的一个设置，TICK的配置，我们选择自己定义一个Tick定时器配置函数，在自己的应用程序中实现： 12345678910111213141516/* 原本的 */86 /*Use a custom tick source that tells the elapsed time in milliseconds. 87 *It removes the need to manually update the tick with `lv_tick_inc()`)*/88 #define LV_TICK_CUSTOM 089 #if LV_TICK_CUSTOM90 #define LV_TICK_CUSTOM_INCLUDE &quot;Arduino.h&quot; /*Header for the system time function*/91 #define LV_TICK_CUSTOM_SYS_TIME_EXPR (millis()) /*Expression evaluating to current system time in ms*/92 #endif /*LV_TICK_CUSTOM*/ /* 改为 */86 /*Use a custom tick source that tells the elapsed time in milliseconds.87 *It removes the need to manually update the tick with `lv_tick_inc()`)*/88 #define LV_TICK_CUSTOM 189 #if LV_TICK_CUSTOM90 #define LV_TICK_CUSTOM_INCLUDE &lt;stdint.h&gt; /*Header for the system time function*/91 #define LV_TICK_CUSTOM_SYS_TIME_EXPR (custom_tick_get()) /*Expression evaluating to current system time in ms*/92 #endif /*LV_TICK_CUSTOM*/ 我们现在是移植lvgl官方的模板，所以直接跑一下他们的例程，去706行将widget例程使能： 12345705 /*Show some widget. It might be required to increase `LV_MEM_SIZE` */706 #define LV_USE_DEMO_WIDGETS 1707 #if LV_USE_DEMO_WIDGETS708 #define LV_DEMO_WIDGETS_SLIDESHOW 0709 #endif 然后保存退出。 4.3 修改main.c​ 我们没有将lvgl的demos移植到工程文件中，所以需要将第2行的demos头文件注释掉： 12 // #include &quot;lvgl/demos/lv_demos.h&quot; 我们还需要根据自己使用的屏幕修改分辨率： 1232 disp_drv.hor_res = 1024; // 原来是80033 disp_drv.ver_res = 600; // 原来是480 另外我们也没有移植原本的鼠标样式，所以也需要注释掉： 1234546 /*Set a cursor for the mouse*/47 // LV_IMG_DECLARE(mouse_cursor_icon);48 // lv_obj_t * cursor_obj = lv_img_create(lv_scr_act()); /*Create an image object for the cursor */49 // lv_img_set_src(cursor_obj, &amp;mouse_cursor_icon); /*Set the image source*/50 // lv_indev_set_cursor(mouse_indev, cursor_obj); /*Connect the image object to the driver*/ 然后保存退出。 4.4 修改Makefile​ 在Makefile中需要指定编译器，如果不知道自己的交叉编译是什么，可以在命令行输入echo $CROSS_COMPILE查看： 12book@100ask:~/workspace/lvgl_demo$ echo $CROSS_COMPILEarm-buildroot-linux-gnueabihf- 可以看到我当前环境使用的是arm-buildroot-linux-gnueabihf-gcc，如果你没有得到这个结果，说明你的交叉编译环境没有设置好，需要去看百问网的手册学习如何构建好交叉编译环境。 ​ 我们将Makefile中的CC ?= gcc修改成我们自己的编译链： 124 #CC ?= gcc5 CC = arm-buildroot-linux-gnueabihf-gcc 因为我们没有移植鼠标样式，所以需要将鼠标样式的连接源文件注释掉： 119 #CSRCS +=$(LVGL_DIR)/mouse_cursor_icon.c 然后保存退出。 4.5 编译和运行​ 在命令行输入make编译工程，如果有报错信息，仔细看提示，不明白的可以百度或者留言交流。 ​ 编译完成后，会在工程目录生成一个可执行文件demo，我们需要将这个文件copy到开发板上，我使用的是网络挂载方式（不明白的可以去看百问网的完全开发手册V4.0版本）。在开发板上将开发板的mnt目录挂载到虚拟机的nfs_rootfs目录： 1[root@100ask:~]# mount -t nfs -o nolock,vers=3 192.168.3.14:/home/book/nfs_rootfs /mnt 然后去虚拟机那边将demo复制到虚拟机的nfs_rootfs目录： 1book@100ask:~/workspace/lvgl_demo$ cp demo ~/nfs_rootfs/ 这样在开发板的mnt目录也会有这个文件了： 12[root@100ask:~]# ls /mntdemo lib stm32mp157c-100ask-512d-v1.dtb uImage 我们将mnt目录下的demo文件复制到本地： 123[root@100ask:~]# cp /mnt/demo ./[root@100ask:~]# lsdemo 然后执行这个文件： 1[root@100ask:~]# ./demo 就可以看到在开发板上的屏幕显示了LVGL的widget例程： 至此LVGL在嵌入式开发板上的简单移植应用就完成了。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://slhking.github.io/tags/Linux/"}]},{"title":"【MM32】第六篇——移植FreeRTOS","date":"2022-05-12T08:06:41.000Z","path":"2022/05/12/MM32-6-PortFreeRTOS/","text":"1. 前言​ 本篇将会从FreeRTOS官网下载内核源码，移植到MM32F320处理器的工程中，验证方法是创建一个任务，在任务中闪烁LED。 2. 移植2.1 获取源码 FreeRTOS 下载版本： 选择LTS版本。 2.2 移植源文件 将下载下来的源码copy到工程目录的【4_Middleware】文件夹下； 添加根目录下的源文件到工程： 添加port的源文件到工程： 这里需要注意的是，要根据自己的编译环境来选择，比如用的armclang，那么则选择RVDS下的port.c；而如果是gcc，那么则选择GCC下的port.c。我们移植的MM32 MindSDK库，是使用的ARM Compiler 6编译器，用的是GCC下的port.c： 添加内存管理文件 我们建议使用heap_4或者heap_5，我们工程中使用的是heap_4： 设置FreeRTOS的配置文件FreeRTOSConfig.h: 这个文件在内核源码中是不存在的，需要我们自己创建保存，我们将其创建保存在【4_Middleware】的根目录下： 这个头文件的内容是根据官方提供的参考，然后再根据自己使用的处理器以及应用场景来配置的，内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#ifndef __FREERTOSCONFIG_H#define __FREERTOSCONFIG_H/* Here is a good place to include header files that are required across your application. */ #include &quot;hal_common.h&quot;#define vPortSVCHandler SVC_Handler #define xPortPendSVHandler PendSV_Handler #define xPortSysTickHandler SysTick_Handler #define configUSE_PREEMPTION 1 #define configUSE_PORT_OPTIMISED_TASK_SELECTION 0 #define configUSE_TICKLESS_IDLE 0 #define configCPU_CLOCK_HZ (72000000) //#define configSYSTICK_CLOCK_HZ (9000000) #define configTICK_RATE_HZ (1000) #define configMAX_PRIORITIES 15 #define configMINIMAL_STACK_SIZE 128 #define configMAX_TASK_NAME_LEN 16 #define configUSE_16_BIT_TICKS 0 #define configIDLE_SHOULD_YIELD 1 #define configUSE_TASK_NOTIFICATIONS 1 #define configTASK_NOTIFICATION_ARRAY_ENTRIES 3 #define configUSE_MUTEXES 1 #define configUSE_RECURSIVE_MUTEXES 0 #define configUSE_COUNTING_SEMAPHORES 0 #define configUSE_ALTERNATIVE_API 0 /* Deprecated! */ #define configQUEUE_REGISTRY_SIZE 10 #define configUSE_QUEUE_SETS 0 #define configUSE_TIME_SLICING 0 #define configUSE_NEWLIB_REENTRANT 0 #define configENABLE_BACKWARD_COMPATIBILITY 0 #define configNUM_THREAD_LOCAL_STORAGE_POINTERS 5 #define configSTACK_DEPTH_TYPE uint16_t #define configMESSAGE_BUFFER_LENGTH_TYPE size_t /* Memory allocation related definitions. */ #define configSUPPORT_STATIC_ALLOCATION 0 #define configSUPPORT_DYNAMIC_ALLOCATION 1 #define configTOTAL_HEAP_SIZE (1024*10) #define configAPPLICATION_ALLOCATED_HEAP 0 #define configSTACK_ALLOCATION_FROM_SEPARATE_HEAP 1 /* Hook function related definitions. */ #define configUSE_IDLE_HOOK 0 #define configUSE_TICK_HOOK 0 #define configCHECK_FOR_STACK_OVERFLOW 0 #define configUSE_MALLOC_FAILED_HOOK 0 #define configUSE_DAEMON_TASK_STARTUP_HOOK 0 /* Run time and task stats gathering related definitions. */ #define configGENERATE_RUN_TIME_STATS 0 #define configUSE_TRACE_FACILITY 0 #define configUSE_STATS_FORMATTING_FUNCTIONS 0 /* Co-routine related definitions. */ #define configUSE_CO_ROUTINES 0 #define configMAX_CO_ROUTINE_PRIORITIES 1 /* Software timer related definitions. */ #define configUSE_TIMERS 1 #define configTIMER_TASK_PRIORITY 5 #define configTIMER_QUEUE_LENGTH 10 #define configTIMER_TASK_STACK_DEPTH configMINIMAL_STACK_SIZE /* Interrupt nesting behaviour configuration. */ #define configKERNEL_INTERRUPT_PRIORITY 255#define configMAX_SYSCALL_INTERRUPT_PRIORITY 191#define configMAX_API_CALL_INTERRUPT_PRIORITY 191/* Define to trap errors during development. */ //#define configASSERT( ( x ) ) if( ( x ) == 0 ) vAssertCalled( __FILE__, __LINE__ ) /* FreeRTOS MPU specific definitions. */ #define configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS 0 #define configTOTAL_MPU_REGIONS 8 /* Default value. */ #define configTEX_S_C_B_FLASH 0x07UL /* Default value. */ #define configTEX_S_C_B_SRAM 0x07UL /* Default value. */ #define configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY 1 #define configALLOW_UNPRIVILEGED_CRITICAL_SECTIONS 1 /* ARMv8-M secure side port related definitions. */ #define secureconfigMAX_SECURE_CONTEXTS 5 /* Optional functions - most linkers will remove unused functions anyway. */ #define INCLUDE_vTaskPrioritySet 1 #define INCLUDE_uxTaskPriorityGet 1 #define INCLUDE_vTaskDelete 1 #define INCLUDE_vTaskSuspend 1 #define INCLUDE_xResumeFromISR 1 #define INCLUDE_vTaskDelayUntil 1 #define INCLUDE_vTaskDelay 1 #define INCLUDE_xTaskGetSchedulerState 1 #define INCLUDE_xTaskGetCurrentTaskHandle 1 #define INCLUDE_uxTaskGetStackHighWaterMark 0 #define INCLUDE_xTaskGetIdleTaskHandle 0 #define INCLUDE_eTaskGetState 0 #define INCLUDE_xEventGroupSetBitFromISR 1 #define INCLUDE_xTimerPendFunctionCall 0 #define INCLUDE_xTaskAbortDelay 0 #define INCLUDE_xTaskGetHandle 0 #define INCLUDE_xTaskResumeFromISR 1 #endif /* __FREERTOSCONFIG_H */ 2.3 设置编译路径要想编译器找到FreeRTOS内核的相关头文件，就需要将这些头文件的所在路径在mdk工程中添加进去： 设置好编译路径后先编译一下，确保编译FreeRTOS的源文件没有问题。 3. 验证3.1 编写驱动文件​ 我们需要配置MM32F3270的时钟，然后还需要控制LED来验证移植，所以还需要写一个LED的驱动；我们还添加了一个调试串口的驱动，都放到了源代码中。 3.2 创建任务​ 由于在FreeRTOSConfig.h中我们没有选择静态分配内存： 12345#define configSUPPORT_STATIC_ALLOCATION 0 #define configSUPPORT_DYNAMIC_ALLOCATION 1 #define configTOTAL_HEAP_SIZE (1024*10) #define configAPPLICATION_ALLOCATED_HEAP 0 #define configSTACK_ALLOCATION_FROM_SEPARATE_HEAP 1 所以只能调用动态分配的那个任务创建函数：xTaskCreate： 123456BaseType_t xTaskCreate( TaskFunction_t pxTaskCode, // 任务的入口函数 const char * const pcName, // 任务的名称 const configSTACK_DEPTH_TYPE usStackDepth, // 分配给任务的栈大小 void * const pvParameters, // 传递给任务的参数 UBaseType_t uxPriority, // 分配给任务的优先级 TaskHandle_t * const pxCreatedTask ) // 返回的任务句柄值 这个函数的返回值： 12pdPASS = 创建成功errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY = 创建失败 根据任务参数的描述，我们需要一个任务的入口函数，形式如：void TestCode(void *parameter)，然后创建一个任务： 123456xTaskCreate(TestCode, \\ // 任务的入口函数 &quot;Test&quot;, \\ // 任务的名称 128, \\ // 分配给任务的栈大小:word NULL, \\ // 传递给任务的参数 1, \\ // 分配给任务的优先级 NULL); // 返回的任务句柄值 3.3 任务函数​ 我们对于任务的示例函数的实现如下： 12345678910111213void TestCode(void *parameter)&#123; volatile uint32_t cnt = 0; printf(&quot;\\r\\nTest Task\\r\\n&quot;); while(1) &#123; Driver_LED_Write(RedLED, LED_ON); vTaskDelay(500); Driver_LED_Write(RedLED, LED_OFF); vTaskDelay(500); printf(&quot;LED task running :%d\\r&quot;, cnt++); &#125;&#125; 在里面闪烁LED，并打印运行次数信息，大约每隔1s打印一次。 3.4 开启任务调度 接口：void vTaskStartScheduler( void ) 当调用这个函数后，正常情况下这个函数之后的代码都不会运行到，比如： 1234567891011121314151617181920int main(void)&#123; volatile uint32_t cnt = 0; SystemClockConfig(); Driver_SysTick_Config(); Driver_LED_Init(); DBG_UART_Init(); xTaskCreate(TestCode, &quot;Test&quot;, 128, NULL, 1, NULL); vTaskStartScheduler(); printf(&quot;Hello China.\\r\\n&quot;); while(1) &#123; &#125; return 0;&#125; 这个代码中【Hello China.】就不会被打印出来。 3.5 现象 ​ 开发板运行这个例程已经有一天多的时间了，从这个计数值也可以看出来，说明移植FreeRTOS到MM32基本没有问题了。","tags":[{"name":"mcu","slug":"mcu","permalink":"http://slhking.github.io/tags/mcu/"},{"name":"MM32","slug":"MM32","permalink":"http://slhking.github.io/tags/MM32/"}]},{"title":"【MM32】第五篇——串口与printf重定向","date":"2022-05-12T08:06:22.000Z","path":"2022/05/12/MM32-5-UartAndPrintf/","text":"1. 概述​ 本篇主要介绍使用MM32的MindSDK开发串口的驱动程序以及重定向printf函数所需要关心的注意事项，由于是使用库开发，比较简单，过程中会着重讲一些注意点，代码的编写仅以代码展示来表现。 2. 初始化UART2.1 配置GPIO​ 评估板上使用的是UART1，用到的引脚是PB6和PB7，将这两个引脚配置位复用输出以及浮空输入： 12345678910111213141516171819202122232425262728293031/* PB6 -- UART1 TX PB7 -- UART1 RX*/#define UART1_TX_PIN GPIO_PIN_6#define UART1_RX_PIN GPIO_PIN_7#define UART1_PORT GPIOB#define UART1_GPIO_CLK_EN() RCC_EnableAHB1Periphs(RCC_AHB1_PERIPH_GPIOB, true)/** * @brief 初始化串口的GPIO * */static void Drv_UART_GPIO_Init(void)&#123; GPIO_Init_Type gpio_init; UART1_GPIO_CLK_EN(); /* PA9 - UART1_TX. */ /* PA10 - UART1_RX. */ gpio_init.Pins = UART1_TX_PIN; gpio_init.PinMode = GPIO_PinMode_AF_PushPull; // 复用推挽输出 gpio_init.Speed = GPIO_Speed_50MHz; GPIO_Init(UART1_PORT, &amp;gpio_init); GPIO_PinAFConf(UART1_PORT, gpio_init.Pins, GPIO_AF_7); gpio_init.Pins = UART1_RX_PIN; gpio_init.PinMode = GPIO_PinMode_In_Floating; // 浮空输入 gpio_init.Speed = GPIO_Speed_50MHz; GPIO_Init(UART1_PORT, &amp;gpio_init); GPIO_PinAFConf(UART1_PORT, gpio_init.Pins, GPIO_AF_7);&#125; 2.2 配置UART参数​ 调试串口使用的是UART1，波特率选择115200，数据位8位，1位停止位，没有校验位： 1234567891011121314151617181920#define UART_INSTANCE UART1#define UART_INSTANCE_CLK_EN() RCC_EnableAPB2Periphs(RCC_APB2_PERIPH_UART1, true)void Drv_UART_Init(void)&#123; UART_Init_Type uart_init; UART_INSTANCE_CLK_EN(); // 使能UART1的时钟 Drv_UART_GPIO_Init(); // 初始化UART1的GPIO uart_init.ClockFreqHz = Drv_GetSysClockFreq()&gt;&gt;1; // 时钟 uart_init.BaudRate = 115200; // 波特率 uart_init.WordLength = UART_WordLength_8b; // 数据位 uart_init.StopBits = UART_StopBits_1; // 停止位 uart_init.Parity = UART_Parity_None; // 校验位 uart_init.XferMode = UART_XferMode_RxTx; // 传输方向：收发 uart_init.HwFlowControl = UART_HwFlowControl_None; // 硬件流控制 UART_Init(UART_INSTANCE, &amp;uart_init); // 将参数配置到寄存器进行初始化 UART_Enable(UART_INSTANCE, true); // 使能UART1&#125; MM32的库还需要配置UART的时钟，一般选择为UART所在总线APB1&#x2F;2的时钟，我的系统里APB总线时钟是系统时钟2分频后输出的： 123456/* 配置系统时钟、AHB、APB时钟 */RCC-&gt;CFGR &amp;= ~(0xF&lt;&lt;4); // AHB不分频RCC-&gt;CFGR |= (4&lt;&lt;8); // APB1 2分频RCC-&gt;CFGR |= (4&lt;&lt;11); // APB2 2分频RCC-&gt;CFGR |= (2&lt;&lt;22); // PLL输出时钟3分频后输出给USB：120MHz/3=40MHzRCC-&gt;CFGR |= (7&lt;&lt;24); // PLL输出时钟2分频后输出到MCO 3. 重定向printf3.1 重定向__FILE结构体​ 在ARM的C&#x2F;C++用户手册中提到，要想重定向printf需要重定向__FILE结构体，但是在MDK下，V6版编译器已经内置重定向了，而V5是没有的，所以我们需要根据所选择的编译器版本来决定是否重定向__FILE结构体： 12345#if defined (__ARMCC_VERSION) &amp;&amp; (__ARMCC_VERSION &lt; 6010050)struct __FILE&#123; int handle;&#125;;#endif 3.2 重定向fputc​ 在MDK下重定向fputc： 123456789FILE __stdout;int fputc(int ch, FILE *f) &#123; /* Your implementation of fputc(). */ while ( 0u == (UART_STATUS_TX_EMPTY &amp; UART_GetStatus(UART_INSTANCE)) ) &#123;&#125; UART_PutData(UART_INSTANCE, (uint8_t)(ch)); return ch;&#125; fputc的函数参数、返回值是固定形式的，只需要在函数体内调用UART的发送函数，将参数ch发送出去即可。 4. 使用​ 我们在main函数内初始化UART后，调用printf打印输出： 123456789101112131415161718192021222324252627282930313233343536#include &quot;drv_led.h&quot;#include &quot;drv_sysclk.h&quot;#include &quot;drv_systick.h&quot;#include &quot;drv_uart.h&quot;#include &quot;hal_common.h&quot;#include &lt;stdio.h&gt;/** * @brief ARM处理器程序入口函数 * * @return int 通常main函数不会有返回值 */int main(void)&#123; /* 定义LED的状态变量，按键按下时取反 */ LED_Status status = off; /* 初始化系统时钟频率为120MHz */ SystemClockConfig(); /* 配置滴答定时器的技术周期是1kHz */ Drv_SysTick_Config(); /* 初始化用户LED的GPIO和默认状态 */ Drv_LED_Init(); /* 初始化串口 */ Drv_UART_Init(); while(1) &#123; /* TDO Your Task */ status = !status; Drv_LED_Write(user_led, status); // 控制LED printf(&quot;LED状态:%s\\r\\n&quot;, (status==on) ? &quot;on&quot; : &quot;off&quot;); HAL_Delay(500); &#125;&#125; 5. 测试结果：","tags":[{"name":"mcu","slug":"mcu","permalink":"http://slhking.github.io/tags/mcu/"},{"name":"MM32","slug":"MM32","permalink":"http://slhking.github.io/tags/MM32/"}]},{"title":"【MM32】第四篇——滴答定时器","date":"2022-05-10T15:21:13.000Z","path":"2022/05/10/MM32-4-TickClock/","text":"1. 前言​ 滴答定时器是cortex内核中的内置定时器，是一个24bit的向下计数定时器。本篇将会介绍滴答定时器的相关寄存器及其配置，实现一个ms级别的延时，通过LED的闪烁来验证，所以需要将LED的驱动移植到本次的工程中。 2. Cortex-M3的滴答定时器​ 本章节主要介绍cortex-m3内核的滴答定时器的相关寄存器，参考手册《Cortex-M3 Devices Generic User Guide》。 2.1 控制和状态寄存器SYST_CSR Bits 名词 描述 [31:17] \\ 保留位 [16] COUNTFLAG 如果滴答定时器的计数值计数到0，那么读取这一位的话就会返回1 [15:3] \\ 保留位 [2] CLKSOURCE 滴答定时器的时钟源：0&#x3D;外部时钟；1&#x3D;处理器时钟 [1] TICKINT 使能滴答定时器的异常请求：0&#x3D;计数到0时不产生SysTick异常请求；1&#x3D;计数到0会产生异常请求； [0] ENABLE 使能计数器：0&#x3D;关闭计数器；1&#x3D;开启计数器 这个寄存器可以设置滴答定时器的时钟源、中断使能及其本身的使能或者关闭，还可以从这个寄存器读取到其是否计数到0。我们需要首先选择这个定时器的时钟源，然后再来使能中断和开启计数器。 滴答定时器的时钟源 ​ 从寄存器的描述可以看到，滴答定时器有两种时钟源：处理器的时钟或者外部时钟。处理器的时钟没啥好说的，我们将处理器的时钟设置为多少，滴答定时器的时钟就是多少，而外部时钟是什么呢？ ​ 滴答定时器的外部时钟是芯片设计厂商，我们来看一下灵动微的MM32F3270给滴答定时器设计的外部时钟是怎样的。在MM32F3270的用户手册时钟树那里前面可以看到： 在MM32F3270处理器中，内核的滴答定时器时钟的外部时钟源还可以是AHB总线时钟8分频后的时钟。 ​ 通常我们会将这个寄存器的值初始化的时候设置为0x7，时钟是处理器的时钟，且使能中断，开启计数器。 2.2 预装载值寄存器SYST_RVR Bits 名称 作用 [31:24] \\ 保留位 [23:0] RELOAD 预装载值，滴答定时器从这个值开始向下计数，计数到0后在下一个周期重新从这个值开始计数 ​ 滴答定时器是一个24bit的向下计数器，所以其预装载寄存器可以设置的位数也只有低24bits，最大可以设置的值是0xFFFFFF&#x3D;16777215。 ​ 假设我们期望滴答定时器每隔1ms进入一次中断，也就是让滴答定时器在其时钟频率下开始向下计数RELOAD这么多次需要耗费的时间是1ms，设滴答定时器的时钟&#x3D;xMHz，那么reload的值就应该是xMHz&#x2F;1kHz &#x3D;xK。比如MM32F3270处理器的AHB总线时钟是120MHz，那么只需要将reload的值设置为120k就可以让滴答定时器每隔1ms进入一次中断，而120k是小于16777215的，是合法的值。 2.3 当前计数值寄存器SYST_CVR Bits 名称 描述 [31:24] Reserved 保留位 [23:0] CURRENT 当前计数值 ​ 这个寄存器很简单，就是表明滴答定时器当前的计数值是多少，可读可写。 2.4 校准值寄存器SYST_CALIB Bits 名称 作用 [31] NOREF 表明设备是否给处理器提供了支持的时钟信号，0&#x3D;提供了；1&#x3D;未提供；如果没有提供支持的时钟，那么滴答定时器的时钟源默认选择系统时钟且对CLKSOURCE那一位的写操作将会被忽略； [30] SKEW 表明TENMS值是否是正确的：0&#x3D;正确；1&#x3D;异常 [29:24] - 保留位 [23:0] TENMS 复位重载值是100ms，用作系统时钟的偏差。如果这个值读出来是0，那么表明校准值就是一个未知值 3. 如何配置滴答定时器3.1 直接调用core_m3.h内联函数​ 在core_m3.h文件中有一个配置滴答定时器的内联函数： 123456789101112131415__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)&#123; if ((ticks - 1UL) &gt; SysTick_LOAD_RELOAD_Msk) &#123; return (1UL); /* Reload value impossible */ &#125; SysTick-&gt;LOAD = (uint32_t)(ticks - 1UL); /* set reload register */ NVIC_SetPriority (SysTick_IRQn, (1UL &lt;&lt; __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */ SysTick-&gt;VAL = 0UL; /* Load the SysTick Counter Value */ SysTick-&gt;CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk; /* Enable SysTick IRQ and SysTick Timer */ return (0UL); /* Function successful */&#125; 它的参数就是设置的预装载值，选择的时钟源默认就是系统时钟，并且也使能了中断，所以我们可以在自己的应用程序中据此做一次封装： 123456789101112131415int Driver_SysTick_Config(void)&#123; uint32_t prioritygroup = 0x00U; uint32_t SystemCoreClock = Driver_GetSysClockFreq(); /* Configure the SysTick to have interrupt in 1ms time basis*/ if(SysTick_Config(SystemCoreClock/1000) &gt; 0) &#123; return -1; &#125; /* Configure the SysTick IRQ priority */ prioritygroup = NVIC_GetPriorityGrouping(); NVIC_SetPriority(SysTick_IRQn, NVIC_EncodePriority(prioritygroup, 15, 0)); return 0;&#125; 我们默认将其预装载值设置为系统时钟除以1000，即每隔1ms进入一次滴答定时器的中断。 3.2 根据寄存器地址映射直接操控寄存器​ 根据前面介绍的滴答定时器的寄存器，按照自己所需设置寄存器的值即可。滴答定时器在内存中映射的基地址是： 各寄存器的地址： 那么我们的程序就可以这样操作： 12345678910111213141516171819202122232425#define SYSTICK_BASE_ADDR (0xE000E010)typedef struct&#123; unsigned int CSR; unsigned int RVR; unsigned int CVR; unsigned int CALIB;&#125;SYSTICK_REG;#define SYSTICK ((SYSTICK_REG*)SYSTICK_BASE_ADDR)int Driver_SysTick_ConfigUseREG(void)&#123; SYSTICK-&gt;RVR = Driver_GetSysClockFreq()/1000 - 1; SYSTICK-&gt;CVR = 0; SYSTICK-&gt;CSR |= (1&lt;&lt;0) | // Enable counter (1&lt;&lt;1) | // Enable Interupt (1&lt;&lt;2); // Clock:cpu clock /* Configure the SysTick IRQ priority */ uint32_t prioritygroup = 0x00U; prioritygroup = NVIC_GetPriorityGrouping(); NVIC_SetPriority(SysTick_IRQn, NVIC_EncodePriority(prioritygroup, 15, 0)); return 0;&#125; 3.3 滴答定时器的中断服务函数12345static volatile uint32_t uwTick = 0;__WEAK void SysTick_Handler(void)&#123; uwTick++;&#125; 4. 验证​ 要验证也很简单，我们利用刚才中断服务函数中的那个全局递增变量，仿照ST的HAL库写一个延时函数： 1234567891011121314151617181920unsigned int HAL_GetTick(void)&#123; return uwTick;&#125;void HAL_Delay(unsigned int Delay)&#123; volatile uint32_t tickstart = HAL_GetTick(); volatile uint32_t wait = Delay; /* Add a freq to guarantee minimum wait */ if (wait &lt; 0xFFFFFFFFU) &#123; wait += (uint32_t)(1); &#125; while ((HAL_GetTick() - tickstart) &lt; wait) &#123; &#125;&#125; 然后操控一个GPIO延时改变电平，即闪烁一个LED： 1234Driver_LED_Write(RedLED, LED_ON);HAL_Delay(500);Driver_LED_Write(RedLED, LED_OFF);HAL_Delay(500); 根据灯的闪烁现象来粗布判断延时是否准确，更精准的测试可以用逻辑分析仪或者示波器来测试引脚的电平翻转时间。","tags":[{"name":"mcu","slug":"mcu","permalink":"http://slhking.github.io/tags/mcu/"},{"name":"MM32","slug":"MM32","permalink":"http://slhking.github.io/tags/MM32/"}]},{"title":"【MM32】第三篇——时钟系统","date":"2022-05-10T05:56:21.000Z","path":"2022/05/10/MM32-3-SystemClock/","text":"1. 前言​ 本文将介绍MM32F3270系处理器的时钟系统，将分别以内部高速时钟HSI、外部高速时钟作为输入时钟源，经锁相环PLL分频和倍频后得到更高的系统时钟，本次代码将会从寄存器层次来配置，而不是使用MindSDK库。 2. 时钟树​ 我们先来认识下MM32F3270的时钟树： 我们将时钟树从【SYSCLK】即【系统时钟】处将这张图一分为二，左侧是时钟输入源以及时钟信号输出到MCO线；右侧是将系统时钟经过分频输出给USB和各总线、外设以及定时器。 ​ 我们可以看到，MM32F3270有四个时钟输入源： HSI——内部高速时钟； HSE——外部高速时钟； LSE——外部低速时钟； LSI——内部低速时钟； 这四个输入时钟皆可用于配置系统时钟SYSCLK，其中HSI和HSE还可以用作PLL的输入源，经过分频和倍频得到更高主频的系统时钟。当配置好系统时钟后，就可以分频配置USB、总线和外设的时钟了。 2.1 HSI配置系统时钟 如果SYSCLK选择以HSI作为系统时钟，那么，SYSCLK的值就是HSI经1&#x2F;2&#x2F;4&#x2F;8&#x2F;16&#x2F;32&#x2F;64&#x2F;128倍分频后的值，最大只能达到HSI的时钟频率8MHz； 如果SYSCLK选择以PLL作为系统时钟，且PLL的输入时钟源来自于HSI，可以看到，是HSI经过1分频后输入到锁相环PLL单元的。也就是说，此时PLL的输入时钟就是HSI的8MHz，然后经PLL的倍频器PLLMUL及其分频器PLLDIV设置倍频系数和分频系数输出给SYSCLK；假设PLLMUL&#x3D;30，PLLDIV&#x3D;2，那么SYSCLK&#x3D;PLLSRC&#x2F;PLLDIV*PLLMUL&#x3D;8MHz&#x2F;2*30&#x3D;120MHz; 2.2 HSE配置系统时钟 和HSI需经过一个分频器再输出给SYSCLK不同的是，当使用HSE直接作为SYSCLK的时钟源时，中间不需要分频，即HSE的时钟频率就是系统频率； 如果SYSCLK的时钟源是PLL且PLL的时钟源是HSE，那么HSE会经过一个固定分频系数的分频器2分频后输入给PLL，然后再经由PLL分频和倍频得到更高的系统时钟，假设HSE&#x3D;8MHz，那么这个时候，PLLDIV就可以设置为1，而PLLMUL照样还是30，同样可以得到120MHz的系统时钟； 2.3 LSI配置系统时钟​ 可以看到，系统时钟还可以选择LSI作为时钟输入源，得到一个更低频的系统时钟。 2.4 时钟输出2.4.1 USB时钟​ 从时钟树的分析可以看到，USB的时钟来自于PLL的输出时钟分频之后的时钟，它支持的最高时钟频率是48MHz，所以如果我们的PLL输出时钟被配置为系统时钟支持的最大时钟频率120MHz，那么USB的时钟最大只能是由PLL经过3分频之后的时钟40MHz；而想要USB工作在最大时钟频率，我们只能将PLL的输出时钟配置为96MHz，再经由2分频后输出给USB，这时候系统时钟的频率也只能达到96MHz。 2.4.2 总线时钟​ MM32F3270的总线有以下几条： AHB总线：时钟是系统时钟SYSCLK经过AHB预分频器分频后产生的； APB1：时钟是AHB总线时钟经APB1预分频器分频后产生的； APB2：时钟是AHB总线时钟经APB2预分频器分频后产生的； 2.4.3 外设和定时器时钟​ 外设分为： AHB总线上的外设：时钟就是AHB总线的时钟； APB1总线上的外设：时钟就是APB1总线的时钟； ABP2总线上的外设：时钟就是APB2总线的时钟； ADC：时钟是APB2总线时钟经ADC预分频器分频后产生的； 高级定时器1和8：时钟是系统时钟SYSCLK经高级定时器预分频器分频后产生的； ​ 定时器分为： 滴答定时器：滴答定时器的时钟可以来自于AHB总线时钟8分频后产生，也可以来自其它时钟源，将分为单独的一章节来介绍内核的滴答定时器； APB1总线上的定时器：如果APB1的预分频系数是1，那么APB1总线上的定时器的时钟就是APB1不分频后产生的时钟；而如果APB1的预分频系数不为1，那么此时APB1总线上的定时器时钟就是将APB1总线的时钟2倍频之后的时钟； APB2总线上的定时器：时钟分析和APB1总线上的定时器时钟类似； 2.4.4 MCO​ MCO：微控制器时钟输出，可以将选择的时钟源输出到MCO引脚上，其来源可以是： PLL输出时钟2分频； HSI; HSE; LSE; SYSCLK; LSI； 2.4.5 RTC时钟​ RTC的时钟来源有2： HSE经128分频后的时钟； LSE； LSI； 2.4.6 独立看门狗IWDG的时钟​ IWDG的时钟只能来源于LSI。 3. 配置系统时钟​ 配置系统时钟除了配置RCC单元之外，还要配合内部FLASH特性和电源管理单元来设置。配合内部FLASH是因为读写内部flash的时候，如果主频过高，就要设置内部flash的预缓冲区和等待周期，目的是为了正常的从flash中读取指令和读写数据；配置电源管理单元则是MM32F3270这个处理器的要求，需要我们去遵从。 3.1 配置内部Flash的参数 使能内部Flash时钟 ​ 内部Flash是挂载再AHB总线上的，因而需要在AHB总线上使能Flash这个外设的时钟，通过查看RCC的AHB寄存器，可以看到是在RCC的AHB1ENR寄存器中使能内部Flash的时钟的： 我们需要将RCC_AHB1ENR的第13位写1： 1RCC-&gt;AHB1ENR |= (1u &lt;&lt; 13u); // 使能FLASH外设 配置等待周期 ​ 在MM32F3270的用户手册中的第【2.3.1】小节有这样一段话： 这段话是中文就不多做解释了，来看一下官方给的系统时钟和Flash latency值之间的关系表： 所以从这个表中我们可以得到，如果要系统时钟工作在96MHz或者120MHz，Flash的latency值需要设置成4，而设置Flash的latency值是在Flash的ACR寄存器： 1FLASH-&gt;ACR |= (4&lt;&lt;0); // 设置Flash的等待周期 3.2 配置电源管理单元​ 此经验是阅读MM32F3270的手册，看到3.5.1章节PWR的CR1寄存器发现的： 所以在配置时钟前，还需要： 12PWR-&gt;CR1 &amp;= ~(2&lt;&lt;14);PWR-&gt;CR1 |= (2&lt;&lt;14); // 如果系统时钟需要达到最大频率 120MHz，需要将 VOS 设置为 2’b10 即 1.7V 3.3 配置HSI用作系统时钟​ 配置HSI用作系统时钟主要由两个步骤： 使能HSI； 配置时钟控制寄存器（RCC_CR）中的HSION 位为1，使能HSI； 等待时钟控制寄存器（RCC_CR）中的 HSIRDY 位被置位为 1，表示 HSI 稳定，可输出有效时钟，此时才可被选择使用作为系统时钟或外设时钟源。 系统时钟源选择HSI； 通过配置时钟配置寄存器（RCC_CFGR）的SW 位来选择系统时钟； 通过读取时钟配置寄存器（RCC_CFGR）的SWS 位，判断当前系统时钟的时钟源。 上电复位后的系统时钟就是HSI 3.4 配置HSE用作系统时钟​ 配置HSE用作系统时钟主要由两个步骤： 使能HSE； 配置时钟控制寄存器（RCC_CR）中的HSEON 位为 1，使能 HSE 等待时钟控制寄存器（RCC_CR）中的HSERDY 位被置位为1，表示 HSE 稳定，会输出有效时钟信号，此时才可被选择使用作为系统时钟或外设时钟源。 系统时钟源选择HSI； 通过配置时钟配置寄存器（RCC_CFGR）的SW 位来选择系统时钟； 通过读取时钟配置寄存器（RCC_CFGR）的SWS 位，判断当前系统时钟的时钟源。 所以根据前面的内容，得到配置代码： 1234567891011121314151617181920static void SystemConfigUseHSE(void)&#123; /* 使能总线外设时钟 */ RCC-&gt;AHB1ENR |= (1u &lt;&lt; 13u); // 使能FLASH外设 FLASH-&gt;ACR |= (4&lt;&lt;0); // 设置Flash的等待周期 /* 使能PWR/DBG */ RCC-&gt;APB1ENR |= (1&lt;&lt;28); PWR-&gt;CR1 &amp;= ~(2&lt;&lt;14); PWR-&gt;CR1 |= (2&lt;&lt;14); // 如果系统时钟需要达到最大频率 120MHz，需要将 VOS 设置为 2’b10 即 1.7V /* 使能HSE */ RCC-&gt;CR |= (1&lt;&lt;16); while(0 == (RCC-&gt;CR&amp;(1&lt;&lt;17)));// 等待HSI稳定 /* 选择HSI作为系统时钟源 */ // 00：选择 HSE 输出用作系统时钟; 01：选择 HSE 输出用作系统时钟; 10：选择 PLL 输出用作系统时钟; 11：选择 LSI 输出用作系统时钟 RCC-&gt;CFGR |= 1; while(0 == (RCC-&gt;CFGR&amp;(1&lt;&lt;1))); // 等待HSE用作系统时钟变&#125; 3.5 配置PLL用作系统时钟3.5.1 HSI用作PLL的输入时钟将HSI用作PLL输入时钟配置高频的系统时钟，步骤如下： 配置时钟控制寄存器（RCC_CR）中的HSION 位为1，使能HSI； 等待时钟控制寄存器（RCC_CR）中的 HSIRDY 位被置位为 1，表示 HSI 稳定，可输出有效时钟，此时才可被选择使用作为系统时钟或外设时钟源； 配置PLL 配置寄存器 （RCC_PLLCFGR）中PLLMUL（倍频系数）和PLLDIV（分频系数）控制位； 配置时钟控制寄存器（RCC_CR）中的PLLON 位为1，使能PLL； 等待时钟控制寄存器（RCC_CR）中的 PLLRDY 位被置位为 1，表示 PLL 稳定，可输出有效时钟，此时才可被选择使用作为系统时钟或外设时钟源。 配置RCC_CFGR选择PLL作系统时钟源并等待稳定； 所以根据前面的内容，得到配置代码： 1234567891011121314151617181920/* 配置HSO和PLL */RCC-&gt;CR |= (1&lt;&lt;0); // 使能HSIwhile(0 == ((RCC-&gt;CR)&amp;(1&lt;&lt;1))); // 等待HSI稳定RCC-&gt;PLLCFGR |= (0&lt;&lt;0); // 配置PLL的时钟源RCC-&gt;PLLCFGR &amp;= ~(0x7F&lt;&lt;16);RCC-&gt;PLLCFGR |= (29&lt;&lt;16); // 配置PLL的倍频系数:30倍RCC-&gt;PLLCFGR &amp;= ~(0x7&lt;&lt;8);RCC-&gt;PLLCFGR |= (0&lt;&lt;8); // 配置PLL的分频系数:1RCC-&gt;CR |= (1&lt;&lt;24); // 使能PLLwhile(0 == (RCC-&gt;CR &amp; (1&lt;&lt;25)));// 等待PLL时钟稳定/* 配置系统时钟、AHB、APB时钟 */RCC-&gt;CFGR |= (0&lt;&lt;4); // AHB不分频RCC-&gt;CFGR |= (4&lt;&lt;8); // APB1 2分频RCC-&gt;CFGR |= (4&lt;&lt;11); // APB2 2分频RCC-&gt;CFGR |= (2&lt;&lt;22); // PLL输出时钟3分频后输出给USB：120MHz/3=40MHzRCC-&gt;CFGR |= (7&lt;&lt;24); // PLL输出时钟2分频后输出到MCORCC-&gt;CFGR |= (2&lt;&lt;0); // 选择PLL输出用作系统时钟while(0 == (RCC-&gt;CFGR &amp; (2&lt;&lt;2))); // 等待PLL输出用作系统时钟稳定 3.5.2 HSE用作PLL的输入时钟将HSE用作PLL输入时钟配置高频的系统时钟，步骤如下： 配置时钟控制寄存器（RCC_CR）中的HSEON 位为 1，使能HSE； 等待时钟控制寄存器（RCC_CR）中的HSERDY 位被置位为1，表示 HSE 稳定，可输出有效时钟，此时才可被选择使用作为系统时钟或外设时钟源； 配置 PLL 配置寄存器（RCC_PLLCFGR）中的 PLLSRC 位为 1，选择 HSE 时钟用作 PLL 输入时钟源； 配置PLL 配置寄存器（RCC_PLLCFGR）中的PLLXTPRE 位，选择HSE 或者HSE 2 分频时钟为PLL 输入时钟源； 配置PLL 配置寄存器 （RCC_PLLCFGR）中PLLMUL（倍频系数）和PLLDIV（分频系数）控 制位； 配置时钟控制寄存器（RCC_CR）中的PLLON 位为1，使能PLL； 等待时钟控制寄存器（RCC_CR）中的 PLLRDY 位被置位为 1，表示 PLL 稳定，可输出有效时钟，此时才可被选择使用作为系统时钟或外设时钟源。 配置RCC_CFGR选择PLL作系统时钟源并等待稳定； 所以根据前面的内容，得到配置代码： 123456789101112131415161718192021/* 配置HSE和PLL */RCC-&gt;CR |= (1&lt;&lt;16); // 使能HSEwhile(0 == ((RCC-&gt;CR)&amp;(1&lt;&lt;17)));// 等待HSE稳定RCC-&gt;PLLCFGR |= (1&lt;&lt;0); // 配置PLL的时钟源RCC-&gt;PLLCFGR |= (1&lt;&lt;1); // 配置PLL的时钟源2分频后再作为时钟输入源RCC-&gt;PLLCFGR &amp;= ~(0x7F&lt;&lt;16);RCC-&gt;PLLCFGR |= (29&lt;&lt;16); // 配置PLL的倍频系数:30倍RCC-&gt;PLLCFGR &amp;= ~(0x7&lt;&lt;8);RCC-&gt;PLLCFGR |= (0&lt;&lt;8); // 配置PLL的分频系数:1RCC-&gt;CR |= (1&lt;&lt;24); // 使能PLLwhile(0 == (RCC-&gt;CR &amp; (1&lt;&lt;25)));// 等待PLL时钟稳定/* 配置系统时钟、AHB、APB时钟 */RCC-&gt;CFGR |= (0&lt;&lt;4); // AHB不分频RCC-&gt;CFGR |= (4&lt;&lt;8); // APB1 2分频RCC-&gt;CFGR |= (4&lt;&lt;11); // APB2 2分频RCC-&gt;CFGR |= (2&lt;&lt;22); // PLL输出时钟3分频后输出给USB：120MHz/3=40MHzRCC-&gt;CFGR |= (7&lt;&lt;24); // PLL输出时钟2分频后输出到MCORCC-&gt;CFGR |= (2&lt;&lt;0); // 选择PLL输出用作系统时钟while(0 == (RCC-&gt;CFGR &amp; (2&lt;&lt;2))); // 等待PLL输出用作系统时钟稳定 3.6 配置总线时钟123456/* 配置系统时钟、AHB、APB时钟 */RCC-&gt;CFGR |= (0&lt;&lt;4); // AHB不分频RCC-&gt;CFGR |= (4&lt;&lt;8); // APB1 2分频RCC-&gt;CFGR |= (4&lt;&lt;11); // APB2 2分频RCC-&gt;CFGR |= (2&lt;&lt;22); // PLL输出时钟3分频后输出给USB：120MHz/3=40MHzRCC-&gt;CFGR |= (7&lt;&lt;24); // PLL输出时钟2分频后输出到MCO ​ 根据RCC_CFGR寄存器以及时钟树的分析来自定义配置。 3.7 综合代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#define __USE_HSE (0)#define __USE_HSE_PLL (1)#define __USE_HSI_PLL (0)void SystemClockConfig(void)&#123; /* 使能总线外设时钟 */ RCC-&gt;AHB1ENR |= (1u &lt;&lt; 13u); // 使能FLASH外设 FLASH-&gt;ACR |= (4&lt;&lt;0); // 设置Flash的等待周期 /* 使能PWR/DBG */ RCC-&gt;APB1ENR |= (1&lt;&lt;28); PWR-&gt;CR1 &amp;= ~(2&lt;&lt;14); PWR-&gt;CR1 |= (2&lt;&lt;14); // 如果系统时钟需要达到最大频率 120MHz，需要将 VOS 设置为 2’b10 即 1.7V RCC-&gt;CR &amp;= ~((1&lt;&lt;16) | (1&lt;&lt;24) ); // 关闭HSE/PLL #if __USE_HSE SystemConfigUseHSE();#elif __USE_HSI_PLL RCC-&gt;CR &amp;= ~(1&lt;&lt;0); // 先关闭HSI /* 配置HSE和PLL */ RCC-&gt;CR |= (1&lt;&lt;0); // 使能HSI while(0 == ((RCC-&gt;CR)&amp;(1&lt;&lt;1))); // 等待HSI稳定 RCC-&gt;PLLCFGR &amp;= ~(1&lt;&lt;0); // 配置PLL的时钟源HSI RCC-&gt;PLLCFGR &amp;= ~(0x7F&lt;&lt;16); RCC-&gt;PLLCFGR |= (29&lt;&lt;16); // 配置PLL的倍频系数:30倍 RCC-&gt;PLLCFGR &amp;= ~(0x7&lt;&lt;8); RCC-&gt;PLLCFGR |= (1&lt;&lt;8); // 配置PLL的分频系数:2#elif __USE_HSE_PLL /* 配置HSE和PLL */ RCC-&gt;CR |= (1&lt;&lt;16); // 使能HSE while(0 == ((RCC-&gt;CR)&amp;(1&lt;&lt;17)));// 等待HSE稳定 RCC-&gt;PLLCFGR |= (1&lt;&lt;0); // 配置PLL的时钟源HSE RCC-&gt;PLLCFGR &amp;= ~(1&lt;&lt;1); // 配置PLL的时钟源HSE不分频后再作为时钟输入源 RCC-&gt;PLLCFGR &amp;= ~(0x7F&lt;&lt;16); RCC-&gt;PLLCFGR |= (29&lt;&lt;16); // 配置PLL的倍频系数:30倍 RCC-&gt;PLLCFGR &amp;= ~(0x7&lt;&lt;8); RCC-&gt;PLLCFGR |= (1&lt;&lt;8); // 配置PLL的分频系数:2#endif RCC-&gt;CR |= (1&lt;&lt;24); // 使能PLL while(0 == (RCC-&gt;CR &amp; (1&lt;&lt;25)));// 等待PLL时钟稳定 /* 配置系统时钟、AHB、APB时钟 */ RCC-&gt;CFGR |= (0&lt;&lt;4); // AHB不分频 RCC-&gt;CFGR |= (4&lt;&lt;8); // APB1 2分频 RCC-&gt;CFGR |= (4&lt;&lt;11); // APB2 2分频 RCC-&gt;CFGR |= (2&lt;&lt;22); // PLL输出时钟3分频后输出给USB：120MHz/3=40MHz RCC-&gt;CFGR |= (7&lt;&lt;24); // PLL输出时钟2分频后输出到MCO RCC-&gt;CFGR |= (2&lt;&lt;0); // 选择PLL输出用作系统时钟 while(0 == (RCC-&gt;CFGR &amp; (2&lt;&lt;2))); // 等待PLL输出用作系统时钟稳定&#125; 4. 获取系统时钟和总线时钟​ 获取系统时钟是根据寄存器的内容，简单的加减乘除后写成程序计算的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#define LSI_VALUE (40000)#define HSI_VALUE (8000000)#define HSE_VALUE (8000000)uint32_t Driver_GetSysClockFreq(void)&#123; uint32_t tmpreg = 0U, prediv = 0U, pllclk = 0U, pllmul = 0U; uint32_t sysclockfreq = 0U; tmpreg = RCC-&gt;CFGR; /* 获取系统时钟源 */ switch(tmpreg &amp; RCC_CFGR_SWS_MASK) &#123; case RCC_SYSCLKSOURCE_STATUS_HSI: &#123; sysclockfreq = HSI_VALUE; break; &#125; case RCC_SYSCLKSOURCE_STATUS_HSE: &#123; sysclockfreq = HSE_VALUE; break; &#125; case RCC_SYSCLKSOURCE_STATUS_LSI: &#123; sysclockfreq = LSI_VALUE; break; &#125; case RCC_SYSCLKSOURCE_STATUS_PLLCLK: &#123; /* 获取PLL的输入时钟源 */ if(RCC-&gt;PLLCFGR&amp;0x01) // HSE用作PLL的输入时钟 &#123; if(RCC-&gt;PLLCFGR&amp;0x02) // HSE二分频后输入给PLL &#123; pllclk = HSE_VALUE&gt;&gt;1; &#125; else // HSE部分变频直接输出给PLL &#123; pllclk = HSE_VALUE; &#125; &#125; else // HSI用作PLL的输入时钟 &#123; pllclk = HSI_VALUE; &#125; prediv = (RCC-&gt;PLLCFGR&gt;&gt;8)&amp;0x07; // PLL的分频系数：PLLCFGR[10:8] pllmul = (RCC-&gt;PLLCFGR&gt;&gt;16)&amp;0x7F; // PLL的倍频系数: PLLCFGR[22:16] sysclockfreq = pllclk * (pllmul+1) / (prediv+1); break; &#125; default:break; &#125; return sysclockfreq;&#125; 5. 验证123456789101112131415#include &quot;driver_sysclk.h&quot;uint32_t sysfreq = 0;int main(void)&#123; SystemClockConfig(); sysfreq = Driver_GetSysClockFreq(); while(1) &#123; &#125; return 0;&#125; 通过调试查看寄存器的值以及变量sysfreq的值是否如预期。","tags":[{"name":"mcu","slug":"mcu","permalink":"http://slhking.github.io/tags/mcu/"},{"name":"MM32","slug":"MM32","permalink":"http://slhking.github.io/tags/MM32/"}]},{"title":"【MM32】第二篇——点亮LED","date":"2022-05-07T06:31:03.000Z","path":"2022/05/07/MM32-2-LightLED/","text":"1. 前言​ 本次实验是在第一篇的基础上进行功能扩展，要实现的是点亮板子上的LED。 2. 工程模板移植 将【Template】工程文件夹copy为另一个工程文件夹【LightLED】 更改工程名字：Template –&gt; LightLED ​ 然后双击打开工程。 根据工程名重新管理工程 配置工程编译输出文件的名称 ​ 如果要编译生成hex文件，则讲途中圈起来的【Create HEX File】这一项勾选上。 设置调试器 ​ 因为工程模板是将配置文件和编译输出文件全部删除掉的，所以需要重新设置下调试器选项，步骤就不再重复说明了。 验证编译 ​ 为确保移植过来的默认设置没有问题，上面的设置好了之后最好先编译一次。 3. 编写LED的驱动3.1 新建LED的驱动源文件和头文件​ 新建文件、保存文件以及添加至工程不再赘述。 3.2 编写LED驱动的头文件​ 我习惯在头文件中对外设硬件驱动的引脚、时钟、硬件名称等，用宏定义的方式在头文件中定义，所以这里我将LED的GPIO相关信息定义到头文件中，而LED的GPIO是哪些我们可以通过板子的原理图获知： 序号 LED 引脚 1 RED PA15 2 GREEN PB3 3 BLUE PB4 4 YELLOW PB5 根据原理图可知，GPIO输出低电平的时候，发光二极管导通发亮，输出高电平的时候熄灭，所以我们在头文件中进行了如下宏定义： 12345678910111213141516171819202122232425262728293031/* driver_led.h */#ifndef __DRIVER_LED_H#define __DRIVER_LED_H#define RED_PIN GPIO_PIN_15#define RED_PORT GPIOA#define RED(STATUS) GPIO_WriteBit(RED_PORT, RED_PIN, STATUS)#define GREEN_PIN GPIO_PIN_3#define GREEN_PORT GPIOB#define GREEN(STATUS) GPIO_WriteBit(GREEN_PORT, GREEN_PIN, STATUS)#define BLUE_PIN GPIO_PIN_4#define BLUE_PORT GPIOB#define BLUE(STATUS) GPIO_WriteBit(BLUE_PORT, BLUE_PIN, STATUS)#define YELLOW_PIN GPIO_PIN_5#define YELLOW_PORT GPIOB#define YELLOW(STATUS) GPIO_WriteBit(YELLOW_PORT, YELLOW_PIN, STATUS)#define LED_GPIO_CLK_EN() &#123;RCC_EnableAHB1Periphs(RCC_AHB1_PERIPH_GPIOA, true);\\ RCC_ResetAHB1Periphs(RCC_AHB1_PERIPH_GPIOA);\\ RCC_EnableAHB1Periphs(RCC_AHB1_PERIPH_GPIOB, true);\\ RCC_ResetAHB1Periphs(RCC_AHB1_PERIPH_GPIOB);&#125;typedef enum&#123; LED_ON = 0, LED_OFF&#125;LED_Status;#endif /* __DRIVER_LED_H */ 3.3 编写LED驱动的源文件 LED的驱动源文件需要知道LED的引脚，所以需要包含我们自己新建的【driver_led.h】； 需要使能LED的GPIO的时钟，所以需要包含HAL库文件【hal_rcc.h】； 需要初始化LED的GPIO，调用的是【hal_gpio.c】里面的函数，所以需要包含【hal_gpio.h】; 123#include &quot;driver_led.h&quot;#include &quot;hal_rcc.h&quot;#include &quot;hal_gpio.h&quot; 编写LED的驱动一般步骤是： 使能GPIO的时钟； 初始化GPIO为输出模式（推挽输出）； 封装LED的输出控制接口； 初始化LED的GPIO 1234567891011121314151617181920212223242526272829303132void Driver_LED_Init(void)&#123; /* 调用GPIO的HAL库对象结构体声明GPIO对象 */ GPIO_Init_Type gpio_init; /* 使能GPIO的时钟 */ LED_GPIO_CLK_EN(); /* 设置GPIO的模式 */ gpio_init.PinMode = GPIO_PinMode_Out_PushPull; gpio_init.Speed = GPIO_Speed_50MHz; /* 选择引脚初始化 */ gpio_init.Pins = RED_PIN; // 红灯 GPIO_Init(RED_PORT, &amp;gpio_init); gpio_init.Pins = GREEN_PIN; // 绿灯 GPIO_Init(GREEN_PORT, &amp;gpio_init); GPIO_PinAFConf(GREEN_PORT, gpio_init.Pins, GPIO_AF_15); gpio_init.Pins = BLUE_PIN; // 蓝灯 GPIO_Init(BLUE_PORT, &amp;gpio_init); gpio_init.Pins = YELLOW_PIN; // 黄灯 GPIO_Init(YELLOW_PORT, &amp;gpio_init); /* 设置LED的默认状态：熄灭 */ RED(LED_OFF); GREEN(LED_OFF); BLUE(LED_OFF); YELLOW(LED_OFF);&#125; 其中对于绿灯的引脚PB3，需要将其复用做普通GPIO。 封装LED的写控制接口 为了便于后续向平台层封装，我们将LED的写控制接口函数名称统一为Driver_LED_Write，考虑到要控制的LED可能不止一个，因而使用了枚举类型将所有的LED类型整合在了一起放到了头文件： 123456typedef enum&#123; RedLED = 0, GreenLED, BlueLED, YellowLED&#125;LED_Type; 那么封装的接口函数实现如下： 123456789101112131415161718192021222324252627void Driver_LED_Write(LED_Type type, LED_Status status)&#123; switch(type) &#123; case RedLED: &#123; RED(status); break; &#125; case GreenLED: &#123; GREEN(status); break; &#125; case BlueLED: &#123; BLUE(status); break; &#125; case YellowLED: &#123; YELLOW(status); break; &#125; default:break; &#125;&#125; 然后将初始化函数接口和写控制接口在头文件中声明，方便别的源文件调用： 12void Driver_LED_Init(void);void Driver_LED_Write(LED_Type type, LED_Status status); 4. 验证4.1 main函数调用LED接口 要调用LED的驱动接口，就需要包含其驱动头文件【driver_led.h】； 在main函数中首先调用初始化LED的函数； 然后再调用LED的写控制接口控制LED； 123456789101112131415#include &quot;driver_led.h&quot;int main(void)&#123; Driver_LED_Init(); Driver_LED_Write(RedLED, LED_ON); Driver_LED_Write(GreenLED, LED_ON); Driver_LED_Write(BlueLED, LED_ON); Driver_LED_Write(YellowLED, LED_ON); while(1) &#123; &#125; return 0;&#125; 4.2 编译烧录​ 代码编写完毕之后，就可以编译看下是否有严重的警告或者错误，如果编译通过了，则可以使用调试器在线调试或者直接烧录到板子上查看现象。","tags":[{"name":"mcu","slug":"mcu","permalink":"http://slhking.github.io/tags/mcu/"},{"name":"MM32","slug":"MM32","permalink":"http://slhking.github.io/tags/MM32/"}]},{"title":"【MM32】第一篇——新建MDK工程","date":"2022-05-07T05:53:14.000Z","path":"2022/05/07/MM32-1-CreateMDKProject/","text":"1. 前言​ 本文的目的是从0开始搭建一个基于MM32单片机的MDK工程，使用的主控芯片是MM32F3277G9P，移植使用的SDK是灵动微官方的MindSDK。 2. SDK的获取2.1 SDK在官网的位置​ 在写本文的时候(2022.5.7)，灵动微官方将其最新的MindSDK放在其官网的【支持】栏中： 要获取这个SDK的资源需要注册登录。 2.2 选择SDK 选择开发工具 官方支持的开发工具有：armgcc、MDK和IAR，按需选择： 本文选择的是MDK。 选择主控 目前(2022.5.7)官方支持的有3种主控对应其三张评估板： ![](MM32-1-CreateMDKProject/choose_board.jpg) 本文选择的是F3270系列的评估板。 构建工程 根据自己的需求选择好开发工具和主控之后，就点击【BUILD PROJECT】构建工程： 构建好之后，就会跳转到生成的SDK样板记录，点击标题即可下载到本地： 3. SDK的结构​ 从官网下载下来的SDK文件目录如图所示： components(组件)：提供了一些三方组件的源文件，如LVGL，内存管理、TinyUSB等； demo_apps：提供了一些三方组件的例程； device：当前处理器的一些库文件和核心文件： 其中【mdk】中的linker下的文件，是MDK工程中需要我们指定的分散加载链接文件，在稍后新建工程的时候会介绍到。 driver_examples：当前处理器基于此SDK的一些驱动例程； 对于中这个SDK，我们要移植到自己工程中的只有【device】下的文件，其它文件夹都是给我们做参考用。 4. 新建工程4.1 构建工程结构​ 在新建MDK工程之前，理应先设计好自己的工程的目录结构，以便于管理文件，这个地方完全根据个人习惯或者公司规定，没有定式，我个人习惯构建如下的工程目录结构： 这些文件夹的作用如图所示： 我们将MM32的SDK中的【device】下的所有文件和文件夹copy到【7_CoreDevice】中： 4.2 创建MM32F3277G9P的MDK工程 新建工程 选择工程的保存路径：【ProjectName】–&gt;【8_Project】； 给工程取名字，例如【Template】，然后保存： 选择主控芯片型号：MM32F3277G9P 选择好之后点击【确定】，然后回弹出来一个管理软件组件的窗口，我们一开始先不管这个，直接点击【OK】。 4.3 管理MDK工程结构​ 刚才初创了MDK工程后，原始的MDK工程结构通常是无法满足我们自己的工程管理需求的，因而需要进行重新设计管理。 改变MDK工程名 点击菜单栏的【工程管理按钮】： 在【Project Targets】中我们可以增加、删除、修改工程名： 我们将目标工程名字和我们之前初创的时候取的工程名一样： 管理目标工程的文件组 在【Groups】窗口中就是当前目标工程会包含的文件组，我们将其设计为和我们在【4.1】小节构建的工程结构一致，只是对于工程结构中的【8_Project】这一项去掉： 当一个文件组中有很多的层次时，比如我们的【7_CoreDevice】中有核心文件，也有HAL库文件，我们可以根据层次进行这样的设计： 添加文件 ​ 当我们将文件组设计好之后，就可以根据这个设计添加文件到对应的组别了，比如我们可以将HAL库文件添加到【7_CoreDevice&#x2F;HAL】这个文件组中： 对于HAL库文件，我们不一定都要全部添加进来，通常都是按需添加。 我们需要添加的MCU核心文件如图所示： 一个是系统配置文件【systetem_mm32f3277g.c】，另一个是系统启动文件【startup_mm32f3277g7.s】。 至此，管理目标工程的基本步骤就到此结束了，如果后续的开发需要添加额外的目标工程、文件组或者文件，根据这几步按需做就好了。 4.4 配置工程​ 当我们管理好基本的工程之后，还要设置这个工程，比如编译器版本选择、编译条件选择、编译路径选择、分散加载等等，我们来分别说明下。 ​ 首先点击菜单栏的【Options for Target】进入工程配置界面： 编译器版本选择 ​ MDK的编译器版本支持V5和V6两种，目前常用的是V5版本，也有V6版本的，V6版本对比于V5，是在编译优化上的提升，通常V6编译速度会比V5快，且MindSDK的分散加载文件的指令用到了V6编译器的指令，所以我们默认还是选择V6版本的编译器： 编译条件 ​ 编译条件主要涉及两个东西，一个是全局宏定义标志，另一个是代码全局设置，比如是否支持C99，优化等级选择多高等等： 红框中选中的是最低等级的优化等级，然后后面的C99使用MindSDK所必须要选择设置上的，因为MindSDK的库文件代码使用了这种标准。 编译路径 ​ 编译器在编译过程中的预处理阶段会去展开源文件中#include的头文件，如果不指定使用到的这些头文件所在的路径，那么编译器就找不到无法展开，编译就会出错，所以我们需要设置这里的编译路径： 凡是源文件中会用到的头文件（自定义的或者库文件的头文件）所在路径都必须在这里设置添加进来，C标准库的不用（比如stdio.h这些）： 选择好之后点击【OK】就完成了编译路径的设置，如果后续有新增文件夹路径，再来这里添加进去就好。 指定分散加载文件 ​ MindSDK有个特别的地方就是，它提供的启动代码在初始化堆栈指针的时候，是通过分散加载文件完成的，而不是直接在启动文件中完成的，就是我们在前文提到的【mdk】中的linker下的那个文件，因而我们需要去指定那个文件到MDK工程的链接中： ① 在【Options for Target】中选择【Linker】项； ② 此项去勾选； ③ 选择MindSDK提供的分散加载文件； 设置好后的结果如下图所示： 设置调试器 根据自己的调试器类型选择，比如ST-Link&#x2F;J-Link等，我使用的是官方评估板，上面自带有他们的MM32-Link： 选择好调试器之后，点击旁边的【Settings】进入调试器设置： ① 点击【Settings】进入设置； ② 此处可以观察调试器是否将PC和处理器正常连接了； ③ 此处勾选上后，在MDK中下载程序到处理器之后，处理器就可以自动复位运行程序； 当上述的工程配置都完成之后，就点击【OK】退出配置。 5. 编译工程5.1 新建源文件&#x2F;头文件​ 经过前面的步骤，我们对当前工程完成了基本设置，但是还缺少一个东西：main函数。至于为何mdk工程必须要有一个确切实现的main函数，大家可以翻阅ARM的C标准库的手册，里面有详细说明。 ​ 我们将main函数放到源文件【main.c】中定义实现，但是当前工程是没有【main.c】的，因而我们需要新建一个： 点击这个快捷键后，在MDK的编辑区就会弹出一个新的文件编辑窗口： 这时候我们点击保存或者按快捷键【ctrl+s】保存： 我们将main.c保存到【1_App】中，理所应当的，文件名处我们就填写【main.c】就好： 然后点击【保存】即可。 ​ 新建文件之后，如果是源文件，且还期望其能被编译，就要将这个文件添加到MDK工程中，添加文件的步骤前面已经讲过了，除了那种方式，我们也可以在目标文件组双击鼠标左键去寻找添加，大家自己尝试： 5.2 编辑文件​ 编辑没啥好说的，根据C语言规则以及我们的设计需求设计程序就好，我们这里做模板工程用，因而就在【main.c】中定义实现main函数就好： 123456#include &lt;stdio.h&gt;int main(void)&#123; return 0;&#125; 5.3 编译​ 按快捷键【F7】或者在菜单栏点击编译选项编译:","tags":[{"name":"mcu","slug":"mcu","permalink":"http://slhking.github.io/tags/mcu/"},{"name":"MM32","slug":"MM32","permalink":"http://slhking.github.io/tags/MM32/"}]},{"title":"嵌入式Linux学习疑惑随手记","date":"2022-04-22T14:52:34.000Z","path":"2022/04/22/LinuxLearnNote/","text":"1. 嵌入式Linux中App开发人员是如何得知可以操控哪些底层硬件的？ 系统会自动挂载，如果没有自动挂载就需要去手动执行挂载命令；我们怎么直到是否自动挂载呢？在终端执行： 1cat /proc/mounts 查看系统设备： 1ls /dev/* -l # 查看所有的设备，包括其主设备号和次设备号 在Linux内核里面，有两类驱动程序：字符(char)设备驱动程序和块(block)设备驱动程序。 图中，c代表字符设备驱动程序， 89就是设备的主设备号，0&#x2F;1&#x2F;2就是设备的次设备号。设备节点对应哪一个设备驱动程序通过主设备号来确定，而次设备号则是决定该设备节点对应的是设备驱动程序中对应的哪一个硬件。 2. Linux中对文件的操作 打开文件：open 需要包含的头文件： 123#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt; 可以调用的API： 12int open(const char *pathname, int flags);int open(const char *pathname, int flags, mode_t mode); 当成功打开一个文件后，open的返回值会是这个文件的描述符句柄，如果打开失败，那么它的返回值就是-1。 参数flags的范围： flags 涵义 O_RDONLY 只读 O_WRONLY 只写 O_RDWR 可读可写 O_APPEND 以附件的方式打开文件，在对该文件进行写的时候，会偏移到文件的末尾开始写 O_ASYNC Enable signal-driven I&#x2F;O: generate a signal (SIGIO by default, but this can be changed via fcntl(2)) when input or output becomes possible on this file descriptor. This feature is available only for terminals, pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs. O_CLOEXEC Enable the close-on-exec flag for the new file descriptor O_CREAT If pathname does not exist, create it as a regular file.这个Flags会用到mode O_DIRECT Try to minimize cache effects of the I&#x2F;O to and from this file. O_DIRECTORY If pathname is not a directory, cause the open to fail O_DSYNC Write operations on the file will complete according to the requirements of synchronized I&#x2F;O data integrity completion. O_EXCL Ensure that this call creates the file: if this flag is specified in conjunction with O_CREAT, and pathname already exists, then open() fails with the error EEXIST. O_LARGEFILE Allow files whose sizes cannot be represented in an off_t (but can be represented in an off64_t) to be opened. O_NOATIME Do not update the file last access time (st_atime in the inode) when the file is read(2). O_NOCTTY If pathname refers to a terminal device—see tty(4)—it will not become the process’s controlling terminal even if the process does not have one. O_NOFOLLOW If pathname is a symbolic link, then the open fails, with the error ELOOP. O_NONBLOCK&#x2F;O_NDELAY When possible, the file is opened in nonblocking mode. O_PATH Obtain a file descriptor that can be used for two purposes: to indicate a location in the filesystem tree and to perform operations that act purely at the file descriptor level. O_SYNC Write operations on the file will complete according to the requirements of synchronized I&#x2F;O file integrity completion(by contrast with the synchronized I&#x2F;O data integrity completion provided by O_DSYNC.) O_TMPFILE Create an unnamed temporary regular file. O_TRUNC If the file already exists and is a regular file and the access mode allows writing (i.e., is O_RDWR or O_WRONLY) it will be truncated to length 0. If the file is a FIFO or terminal device file, the O_TRUNC flag is ignored. Otherwise, the effect of O_TRUNC is unspecified. 当flags支持O_CREAT时，可以选择的mode有： mode 作用 S_IRWXU user (file owner) has read, write, and execute permission S_IRUSR user has read permission S_IWUSR user has write permission S_IXUSR user has execute permission S_IRWXG group has read, write, and execute permission S_IRGRP group has read permission S_IWGRP group has write permission S_IXGRP group has execute permission S_IRWXO others have read, write, and execute permission S_IROTH others have read permission S_IWOTH others have write permission S_IXOTH others have execute permission S_ISUID set-user-ID bit S_ISGID set-group-ID bit S_ISVTX sticky bit 其中，user&#x2F;group&#x2F;others指代的什么？ 示例：打开一个“只读”文件测试代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;/** * @brief * ./open hello.txt * @param argc * @param argv * @return int */int main(int argc, char const *argv[])&#123; char buf[1024] = &#123;0&#125;; int len = 0; printf(&quot;Open a file by read only.\\r\\n&quot;); int fd = open(argv[1], O_RDONLY); if(fd == -1) printf(&quot;Open file failed.\\r\\n&quot;); printf(&quot;Read file: \\r\\n&quot;); while( (len = read(fd, buf, 1024)) &gt; 0 ) &#123; printf(&quot;%s&quot;, buf); &#125; printf(&quot;\\r\\n&quot;); printf(&quot;Try to write: ABCD\\r\\n&quot;); len = write(fd, &quot;ABCD&quot;, 4); if(len == -1) printf(&quot;Write to file failed.\\r\\n&quot;); close(fd); return 0;&#125; 输出结果： 1234567book@100ask:~/workspace/FileOption$ ./open_ro hello.txt Open a file by read only.Read file: Hello World!Try to write: ABCDWrite to file failed.","tags":[{"name":"随笔","slug":"随笔","permalink":"http://slhking.github.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"Linux","slug":"Linux","permalink":"http://slhking.github.io/tags/Linux/"}]},{"title":"【ROS】第二篇——快速体验","date":"2022-04-22T09:36:56.000Z","path":"2022/04/22/ROS-2-GetStarted/","text":"​ 本文参考的是赵虚左老师的博客和视频。主要目的是记录一下快速使用ROS输出Hello World!这个信息的步骤。 1. 概述​ ROS设计的编程语言主要是C++和python，使用哪一门语言进行开发取决于我们熟悉使用哪一门语言。 ​ 实现输出Hello World!的步骤分为如下几步： 创建一个工作空间； 在工作空间中创建一个功能包； 编辑源文件； 编辑配置文件； 编译并执行； 2. 创建和编译2.1 创建工作空间并初始化123mkdir -p 自定义空间名称/srccd 自定义空间名称catkin_make 需要注意的是，使用mkdir创建工作空间的时候，后面必须要有/src；初始化的时候，必须是在创建好的工作空间内进行初始化。 2.2 进入src创建ros功能包并添加依赖12cd srccatkin_create_pkg 自定义ROS包名 roscpp rospy std_msgs 123roscpp: C++的依赖包rospy: python的依赖包std_msgs: 标准输入输出的依赖包 2.3 使用C++实现输出Hello World2.3.1 ROS功能包内容 进入刚才创建的ros功能包： 1cd ros功能包 可以看到这里面也有一个src文件夹，我们需要将当前ros功能包要实现的功能的源代码文件放在这个文件夹下，头文件放在ros功能包中的include文件夹下。需要注意区分工作空间下的src文件夹和ros功能包中的src文件夹。 2.3.2 创建和编辑节点源文件 进入ros功能包中的src文件夹新建源文件 12cd srcgedit hello.cpp 使用gedit新建并打开hello.cpp，如果不是在vmware或者vxwork中而是使用ssh连接虚拟机的话，需要将gedit换做vim。 编辑hello.cpp 12345678910111213#include &quot;ros/ros.h&quot;int main(int argc, char *argv[])&#123; //执行 ros 节点初始化 ros::init(argc,argv,&quot;hello&quot;); //创建 ros 节点句柄(非必须) ros::NodeHandle n; //控制台输出 hello world ROS_INFO(&quot;hello world!&quot;); return 0;&#125; 我们要使用ros的库API，需要包含它的头文件。在main函数中，一个简单的ros节点创建和信息输出总结为如下几步： 使用ros-&gt;init接口初始化节点，第三个参数是节点名称； 使用ros-&gt;NodeHandle 创建当前ros节点的句柄； 调用ros标准信息输出接口ROS输出信息； 编辑好源代码之后保存退出编辑； 2.3.3 编译配置文件 编辑ros功能包中的配置文件CMakelist.txt 12cd ~/工作空间/src/ros功能包gedit CMakelist.txt 找到默认被注释掉的add_executable和target_link_libraries，默认分别是在136行和149行： 将他们按照下面的格式修改： 123456add_executable(步骤3的源文件名 src/步骤3的源文件名.cpp)target_link_libraries(步骤3的源文件名 $&#123;catkin_LIBRARIES&#125;) 然后保存退出编辑。 2.3.4 编译功能包 进入工作空间根目录编译 12cd ~/Desktop/工作空间catkin_make 如果提示编译失败： 则根据提示去修改，比如我们这里最初提示在配置文件CMakelist.txt中没有找到hello_node.cpp，也就是我们的配置文件没有修改正确，那我们又去ros功能包中修改CMakelist.txt文件： 再重新回到工作空间编译，编译成功会有如下提示： 3. 执行​ 需要打开两个终端： 在终端1中启动ROS： 1roscore 在终端2中启动编译出来的ros节点 123cd ~/工作空间source ./devel/setup.bashrosrun 包名 C++节点 当我们执行后看到了打印信息则证明我们的ROS环境搭建基本没有问题。 source ~/工作空间/devel/setup.bash可以添加进.bashrc文件，使用上更方便，这一步是配置环境变量。","tags":[{"name":"ROS","slug":"ROS","permalink":"http://slhking.github.io/tags/ROS/"}]},{"title":"【ROS】第一篇——环境搭建","date":"2022-04-22T08:42:02.000Z","path":"2022/04/22/ROS-1-SetupEnv/","text":"​ 本文参考的是赵虚左老师的博客以及视频。 1. 安装虚拟机​ 需要下载的软件：VxWork或者vmware以及ubuntu虚拟机镜像，ubuntu镜像学习使用的版本是20.04。虚拟机的安装步骤比较简单，网上有很多参考，这里略过不写。 2. 安装ROS2.1 配置ubuntu的软件和更新 需要保证途中的复选框都勾选上，且下载自那个地方要选择一个国内的服务器。 2.2 设置安装源 默认的安装源： 1sudo sh -c &#x27;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27; 国内清华的安装源： 1sudo sh -c &#x27;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27; 国内中科大的安装源： 1sudo sh -c &#x27;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.ustc.edu.cn/ros/ubuntu/ `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27; 2.3 设置ROS的key1sudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu.com:80&#x27; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 2.4 更新源sudo apt update 2.5 安装ROSsudo apt install ros-noetic-desktop-full 这个安装过程受限于网络环境和网络速度，过程可能比较漫长，而且过程中还可能会报错，如果报错了就重新执行这条命令，它会从错误的地方开始继续安装，不会从头安装。需要耐心等待。 2.6 配置环境变量12echo &quot;source /opt/ros/noetic/setup.bash&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc 3. ROS依赖安装 首先安装构建依赖的相关工具： sudo apt install python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essential 初始化rosdep 12sudo rosdep initrosdep update 如果一切顺利的话： 但是一般都会在rosdep update这一步出错，在这一步，如果能翻墙的话可以翻墙后重复执行一直到成功，如果不能翻墙，则参考赵虚左老师的方法：http://www.autolabor.com.cn/book/ROSTutorials 4. 验证环境 开启三个终端（ctrl+shift+t可以打开一个终端）； 终端1输入指令：roscore；开启ROS核心控制器 终端2输入指令：rosrun turtlesim turtlesim_node；开启乌龟控制图形界面 终端3输入指令：rosrun turtlesim turtle_teleop_key；开启获取键盘鼠标的ros程序 将鼠标光标放置终端3窗口，然后按下键盘的上下左右键，如果能控制乌龟则说明ROS环境搭建完成；","tags":[{"name":"ROS","slug":"ROS","permalink":"http://slhking.github.io/tags/ROS/"}]},{"title":"【美食】土豆烧排骨","date":"2021-04-10T06:23:17.000Z","path":"2021/04/10/DeliciousFood-1-PotatoRibs/","text":"​ 本篇是记录土豆少排骨这道菜第一次学习烹饪的过程以及总结。 教学老师： 哔哩哔哩Up主： 迷迭香美食 视频地址：简单美味的土豆炖排骨，香到骨子里！材料 序号 名称 数量 1 排骨 1匹 2 土豆 小的2-3个 3 葱姜蒜 少许 4 糖 一勺 5 胡椒粉 一小勺 6 料酒 一勺 7 生抽 一勺 8 老抽 一勺 耗时 焯水：10分钟左右 翻炒如果：5分钟左右 大火烧开：5分钟左右 小火煮：20分钟+15分钟，大约35分钟左右 总计耗时：1小时左右步骤 第一步，排骨焯水，冷水焯水，开水煮开后撇去浮沫，放入葱姜，继续焯水大概3分钟左右，捞出备用； 第二步，焯水过程中，将土豆剥皮，切成块，备用； 第三步，热锅，倒油少许，5分热的时候放入姜片和蒜片，翻炒出香味之后倒入排骨，将排骨炒至金黄色； 第四步，然后把翻炒后的排骨放到砂锅里面，加入料酒、生抽、老抽、糖、胡椒粉、一勺盐，随后加入热水，水量将恰好排骨淹没就足够了； 第五步，大火将砂锅中的水烧开，转小火煮20分钟左右； 第六步，20分钟后，把土豆倒入砂锅里，搅拌下，使其均匀受热；随后小火继续煮15分钟左右； 第七步，出锅，摆盘，将汁水淋到土豆排骨上，最后撒上一点葱花，完美；我的成果​ &#x3D;-&#x3D;没拍照经验​ 这道菜挺简单的，按照视频教的步骤一步一步做就好了~味道挺好的！","tags":[{"name":"土豆烧排骨","slug":"土豆烧排骨","permalink":"http://slhking.github.io/tags/%E5%9C%9F%E8%B1%86%E7%83%A7%E6%8E%92%E9%AA%A8/"},{"name":"美食","slug":"美食","permalink":"http://slhking.github.io/tags/%E7%BE%8E%E9%A3%9F/"}]},{"title":"【美食】学习做梅菜扣肉","date":"2021-04-10T05:25:13.000Z","path":"2021/04/10/DeliciousFood-2-Preserved Vegetable & Pork/","text":"​ 本篇是记录梅菜扣肉这道菜第一次学习烹饪的过程以及总结。 教学老师： 哔哩哔哩Up主： 黎叔教做菜 视频地址：【咸烧白】四川名菜咸烧白，你们那叫什么？材料 序号 名称 数量 1 瘦一点的五花肉 800克 2 芽菜 根据肉量定 3 豆豉 一勺 4 姜 三四片 5 葱 一根 耗时 煮五花肉：30分钟； 静置、烧开水、炸皮、泡皮、刮皮洗净：20分钟 准备芽菜：5分钟 蒸：60分钟 总共耗时：约2小时步骤 第一步，锅中接入冷水，五花肉肉朝下，皮朝上，放入水中煮，水煮开之后，把浮沫捞走，放入葱姜，继续煮20分钟左右； 第二步，20分钟后，把肉捞出来，放在那种可以漏水的盆里，把皮上煮出来的油刮掉，然后使用老抽趁热上色，最主要的是要上色均匀。上好色之后静置，放冷；在这个过程中可以同时烧一点开水备用； 第三步，锅中倒入油，热油到7、8成的时候，把五花肉的皮向下炸，炸到起皱纹的时候捞出来，一般这个过程挺快的，注意看； 第四步，捞出来后，放到一个大碗里面，用准备好的开水泡，这样是为了让皮的焦味变小，泡的时候皮要向下，泡10分钟左右； 第五步，10分钟后，把皮的皱纹刮掉，刮出金黄色，然后把五花肉清洗干净； 第六步，芽菜用清水清洗2-3次，然后热锅，锅中不需要加入油，把芽菜放到锅里面一直翻炒，直到把芽菜翻炒成一颗一颗可以散开的状态； 第七步，把炒好的芽菜盛到一个碗里面，然后加入切好的泡椒，一勺豆豉，一勺生抽，一勺料酒，7、8颗花椒，搅拌均匀； 第八步，切肉；把五花肉四边修一下，然后顺着五花肉的筋络切，厚度按照筷子的直径比较合适；通常切10片，八片摆在碗的中间，2片分别摆在两边； 第九步，把搅拌好的芽菜添加到摆好的五花肉上，把肉全部覆盖，堆叠成一个尖堆堆，然后压紧一点； 第十步，蒸；蒸锅中加入足够的水，因为要大火蒸一个小时左右；把五花肉放到蒸格上，大火蒸一个小时； 第十一步，成型；一小时后，把五花肉倒扣到另一个碗里面，梅菜扣肉出锅；我的成果 经验​ 这是我第一次做烧白，就成果而言是不合格的。总结了下以下几点没有做好的地方： 五花肉买肥了，导致烧白吃着很闷，容易腻； 切肉的时候切厚了，导致本就肥的烧白吃起来更腻了； 上色上的薄了，这个原因不太好确定，因为我在上色的时候用老抽上了好几次，但是结果还是颜色没黎叔那样好看；有可能是炸皮的时候火候大了或者炸久了，导致后面刮的时候刮掉了太多；","tags":[{"name":"美食","slug":"美食","permalink":"http://slhking.github.io/tags/%E7%BE%8E%E9%A3%9F/"},{"name":"梅菜扣肉","slug":"梅菜扣肉","permalink":"http://slhking.github.io/tags/%E6%A2%85%E8%8F%9C%E6%89%A3%E8%82%89/"}]},{"title":"Hexo指令","date":"2021-04-04T09:36:50.000Z","path":"2021/04/04/Hexo指令/","text":"说明：本文档作为Hexo新手学习笔记文档，遇到新命令即记录，不定时更新ing。 1. 发布文章1. hexo new [layout] &lt;title&gt; 新建一篇文章，如果没有使用layout的话，默认使用_config.yml中的default_layout代替。如果title含空格，使用双引号括起来： hexo new &quot;my test&quot; 参数： 参数 描述 –p, –path 自定义新文章的路径 -r, –replace 如果存在同名文章，将其替换 -s, –slug 文章的 Slug，作为新文章的文件名和发布后的 URL 文章的属性： 设置 描述 默认 layout Layout post或者page title 文章的标题 文章的文件名 data 创建日期 文件建立日期 updated 修改日期 文件更新日期 comments 是否开启评论 trus tags 标签 categories 分类 permalink 覆盖文章网址 文件名 keywords 仅用于 meta 标签和 Open Graph 的关键词（不推荐使用） 新建草稿： hexo new draft &quot;草稿&quot; 发布草稿： hexo publish &quot;草稿&quot; 给文章添加分类和标签： 1234567categories:- 分类- 子分类- 子子分类tags:- 标签1- 标签2","tags":[{"name":"随笔","slug":"随笔","permalink":"http://slhking.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}]